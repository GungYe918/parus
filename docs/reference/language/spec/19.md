## 8. 표현식과 연산자, 파이프 << 와 hole _

### 8.0 RAII v0 상태

* `class` 값 중 `deinit` 대상은 스코프 종료 시 자동 정리된다.
* 자동 정리 경로는 블록 자연 종료, `return`, `break`, `continue`를 모두 포함한다.
* 같은 스코프 내 정리 순서는 선언 역순(LIFO)이다.
* `&&place`로 이동된 값은 moved로 표시되어 자동 `deinit` 대상에서 제외된다.
* lifecycle 직접 호출(`a.deinit()`, `A::deinit(...)`)은 금지되며 컴파일러가 정리 시점을 관리한다.
* nested drop glue는 v0 범위 밖이며, `deinit` 대상 class를 class 인스턴스 필드로 포함하는 선언은 금지된다.

### 8.1 기본 연산자

* 산술: + - * / %
* 비교: == != < <= > >=
* 논리: and or ! not xor
* 대입: = += -= *= /= %=
* 인덱싱: []
* 삼항: cond ? a : b (중첩 금지, v0 강제)
* 범위: a..b, a..:b
* 증감: x++, ++x

증감 연산자 규칙 (v0 권장):

* x++ : 후위 증가. 결과는 "증가 전 값"이다.
* ++x : 전위 증가. 결과는 "증가 후 값"이다.
* x가 mut 바인딩이어야 한다.
* acts 기반으로도 모델링할 수 있으나, v0에서는 기본 수치 타입에 대해 내장으로 제공해도 된다.

예시

```parus
def exprs() -> void {
  set a = 1 + 2 * 3;
  set ok = (a >= 7) and (a != 0);
  set r = ok ? 10 : 20; // 중첩은 금지

  set mut x = 10;
  set y = x++;  // y=10, x=11
  set z = ++x;  // x=12, z=12
}
```

### 8.2 파이프 연산자 << 와 hole _

정의:

* lhs << CallExpr 형태만 허용한다.
* CallExpr 내부에 _ 가 정확히 1개 있어야 한다.
* _ 는 라벨 인자 자리에서만 허용한다.
* 변환 규칙:

  * lhs << f(a: _, b: 2)  ==  f(a: lhs, b: 2)

예시

```parus
def add(a: int, b: int) -> int { return a + b; }

def mul(x: int, y: int) -> int { return x * y; }

def pipe_demo() -> void {
  set r = 1 << add(a: _, b: 2) << mul(x: _, y: 10);
}
```

### 8.3 borrow `&`와 escape `&&`

---

### 8.3.1 목적: 작은 데이터는 값, 공유/탈출은 명시적으로

Parus은 기본적으로 **값(move) 기반**이다. v0에서는 Rust급의 복잡한 수명 추론을 강제하지 않되, C/C++의 “참조/포인터가 슬쩍 탈출하여 수명 버그를 만드는 문제”를 구조적으로 차단한다.

이를 위해 두 연산자를 제공한다.

* `&`  : **비탈출(non-escaping) 접근 권한(borrow capability)** 생성
* `&&` : **소유권 탈출(escape) 승격**. 값을 “탈출 가능한 소유 객체”로 승격

이 연산자들은 런타임 오버헤드를 만들기 위한 것이 아니라, **컴파일 타임 정적 규칙 + 표현(ABI) 고정**을 통해 안전성과 최적화를 동시에 얻기 위한 장치다.

또한 Parus에서 `&&`는 논리 AND가 아니며, 논리 연산은 `and/or/not/xor` 키워드만 사용한다.

---

### 8.3.2 borrow `&`의 의미론

#### (1) `&`는 포인터가 아니라 “접근 권한 토큰”

`&x`는 `x`의 주소를 외부에 노출하는 포인터가 아니다.
`&x`는 “이 스코프 안에서 x에 접근할 수 있는 권한”을 나타내는 **borrow 값**을 만든다.

borrow는 두 종류다.

* `&T` : 읽기 전용 borrow
* `&mut T` : 쓰기 가능 borrow (배타적)

#### (2) borrow의 핵심 제약: 비탈출(non-escaping)

v0의 단순하고 강한 규칙:

> borrow 값(`&T`, `&mut T`)은 **절대 탈출할 수 없다.**

탈출 금지에는 아래가 포함된다.

* 함수 반환값으로 반환 금지
* 전역/actor draft/field/class 멤버에 저장 금지
* 배열/리스트/클로저 캡처에 저장 금지
* FFI로 전달 금지(ABI 경계)
* `&&`로 승격 금지(= borrow를 escape로 바꾸는 것 금지)

즉 borrow는 “잠깐 쓰고 끝내는” 용도다.

#### (3) borrow의 수명: 렉시컬(블록) 기반

v0에서는 borrow 수명을 **렉시컬 스코프(블록)** 로 본다.

* `set r = &x;` 하면 `r`은 그 블록 끝까지 유효하다.
* 더 짧은 수명을 원하면 `{ ... }` 블록을 사용한다.

(향후 v1+에서는 NLL(마지막 사용점 기반 단축) 같은 최적화를 도입할 수 있으나, v0은 단순성을 우선한다.)

#### (4) `&mut`의 배타 규칙(충돌 규칙)

동일 스코프/동일 수명 구간에서:

* `&mut x`가 존재하는 동안, `x`에 대한 다른 borrow(`&x` 또는 `&mut x`)는 금지된다.
* 또한 `x` 자체에 대한 직접 접근(읽기/쓰기)도 제한될 수 있다.
  v0 권장 규칙: `&mut x`가 살아있는 동안 `x`를 직접 읽거나 쓰는 행위는 금지한다.

이 규칙은 런타임 락이 아니라 **컴파일 타임 검사**다.

#### (5) borrow 대상은 “place expression”이어야 한다

`&` / `&mut`는 임시값에 붙을 수 없다. 반드시 저장 위치(place)를 가리켜야 한다.

v0에서 place expression의 최소 집합:

* `Ident`
* `place . Ident` (필드 접근)
* `place [ Expr ]` (인덱싱, 해당 표현식이 place를 반환하는 경우)

예:

* `&(a + b)` 는 에러 (임시값)
* `&arr[i]` 는 가능(배열 요소가 place인 경우)

---

### 8.3.3 escape `&&`의 의미론

#### (1) `&&x`는 “소유권을 탈출 가능한 소유 핸들”로 승격

`&&x`는 `x`의 소유권을 소비(consumed)하고, 결과를 **escape handle** 로 만든다.

* `x`는 사용 불가(소유권 이동)
* 결과는 **고정된 ABI(3word)** 로 표현되는 “소유 핸들 값”이다.

핵심: `&&`는 “라이브러리 타입을 호출하는 문법 설탕”이 아니다.
`&&`는 **언어 코어 의미론 + ABI가 고정된 핵심 연산자**이며, freestanding에서도 자체적으로 완결된다.

#### (2) `&&`의 대상도 place expression이어야 한다

`&&`는 임시값에 붙을 수 없다.

* `&&(a + b)` : 에러
* `&&obj` : 가능(소유권 이동)

#### (3) `&&`는 borrow에 적용할 수 없다

borrow는 비탈출이므로, 아래는 금지된다.

* `&&(&x)` : 에러
* `&&r` (r: &T) : 에러

#### (4) `pure` / `comptime` 제약

* `&&`와 `pure`/`comptime`의 결합 규칙은 v0에서 상세를 보류한다.

---

### 8.3.4 예시

#### 예시 1: 읽기 전용 borrow

```parus
def sum2(a: &i32, b: &i32) -> i32 {
  return a + b;
}

def demo_read_borrow() -> void {
  let x: i32 = 10;
  let y: i32 = 20;
  let s: i32 = sum2(a: &x, b: &y);
}
```

#### 예시 2: `&mut`로 수정 권한 위임

```parus
def inc(x: &mut i32) -> void {
  x = x + 1;
}

def demo_write_borrow() -> void {
  let mut a: i32 = 0;
  inc(x: &mut a);
}
```

#### 예시 3: borrow 비탈출 규칙(금지 사례)

```parus
def bad_return_ref() -> &i32 {
  let x: i32 = 3;
  return &x;   // error: borrow 값은 함수 밖으로 탈출할 수 없다
}

def bad_store_global() -> void {
  // draft.someRef = &x; // error: draft/field/class 멤버 저장 금지
}
```

#### 예시 4: `&&`로 소유권 탈출(escape)

```parus
class File {
    def close() -> void { /* ... */ }
}

def open_file() -> Handle<File> {
  set f = File();
  return &&f;
}
```

> 주의: 위 예시의 `Handle<File>`은 “표면 문법상의 표기”일 뿐이며, `&&`의 결과 ABI는 아래 8.3.5에서 **ptr/meta/ctrl 3word**로 고정된다.
> (언어는 특정 라이브러리 이름에 의존하지 않는다.)

#### 예시 5: `&mut` 배타 규칙(충돌)

```parus
def demo_exclusive() -> void {
  let mut x: i32 = 1;

  set r = &mut x;
  // set s = &x;     // error: &mut x 살아있는 동안 다른 borrow 불가
  // set t = x + 1;  // error(v0 권장): &mut x 살아있는 동안 직접 접근 금지

  r = r + 1;
}
```

#### 예시 6: 논리 연산은 키워드만 사용

```parus
def demo_logic() -> void {
  set a = true;
  set b = false;

  if (a and not b) {
    // ...
  }

  // if (a && b) { } // error: &&는 escape 연산자, and를 사용할 것
}
```

---

### 8.3.5 `&&` 구현 지침 (의미론 고정 + 3word fat handle ABI)

`&&`는 **항상** “탈출 가능한 소유 핸들(handle) 생성”을 의미한다.
컨텍스트에 따라 의미가 달라지는 동작(예: 어떤 경우엔 단순 move, 어떤 경우엔 refcount 등)은 v0에서 금지한다.

### (1) 결과 ABI: `&&`는 항상 3word(handle3)로 표현된다

v0에서 escape handle은 다음 3word로 고정된다.

* **`ptr`**  : 객체(또는 객체 헤더) 주소
* **`meta`** : 타입 메타 포인터(type meta). drop/move/clone 등의 정적 정보를 제공
* **`ctrl`** : 최적화/소거를 위한 제어 워드(태그/비트필드)

즉 `&&x`의 결과는 언제나:

```
handle3 = (ptr, meta, ctrl)
```

이 3word는 **언어 차원의 ABI**이며, 라이브러리 타입 이름과 무관하게 유지된다.

---

### (2) `ptr` / `meta` / `ctrl`의 의미(정확한 정의)

#### 2.1 `ptr` (word0)

* 기본적으로 “소유 대상 객체의 주소”다.
* 객체가 “직접 객체”인지 “헤더를 가진 박스 객체”인지는 `ctrl`의 태그로 구분한다.

#### 2.2 `meta` (word1)

* `meta`는 **정적 타입 `T`에 대해 컴파일러가 생성한 타입 메타 객체의 주소**다.
* 타입 메타에는 최소로 다음 정보가 포함된다(개념적).

  * `drop_fn(ptr)` : 파괴자 호출/자원 해제 코드의 진입점 (없으면 null)
  * `move_fn(dst, src)` : 이동 생성(필요하면)
  * `size`, `align` : 타입 크기/정렬 (일부 최적화에 사용)
  * (선택) `flags` : trivial drop/trivial move 등의 성질

> 중요한 점: `meta`는 “런타임에서 찾아오는 것”이 아니라, **컴파일러가 생성한 정적 데이터**를 가리킨다.
> 따라서 `meta` 로딩 자체는 런타임 비용이 아니라 “상수 포인터 로드”에 가깝다.

#### 2.3 `ctrl` (word2)

`ctrl`은 “소거와 인라이닝이 진짜 잘 먹히는 형태”를 목표로, 아래처럼 **하위 비트를 태그로 고정**하고, 나머지는 “증명 가능한 추가 정보”로 사용한다.

권장 비트 레이아웃(v0):

```
ctrl[ 2:0 ] = KIND (3-bit tag)
ctrl[ 3 ]   = HAS_DROP (1 if drop needed, else 0)
ctrl[ 4 ]   = MOVED_OUT (compiler-only SSA flag; stored only when materialized)
ctrl[ 5 ]   = PINNED (future; v0 reserved = 0)
ctrl[15:6 ] = AUX_SMALL (10-bit small aux, meaning depends on KIND)
ctrl[63:16] = AUX_LARGE (48-bit aux / pointer / index; meaning depends on KIND)
```

KIND 태그 정의(v0):

* `KIND=0 (TRIVIAL)`

  * “소유하지만 드랍이 관측 불가 / 드랍 필요 없음” 또는 “드랍이 no-op”
  * `HAS_DROP=0`이 강제되는 것이 권장
  * 소거 최적화가 가장 잘 먹히는 형태

* `KIND=1 (STACK_SLOT)`

  * `ptr`는 “현재 함수의 스택 프레임 내 슬롯 주소”
  * `AUX_SMALL`에 “frame slot id(또는 offset/8 단위 인코딩)”을 넣을 수 있음
  * 이 handle은 함수 밖으로 탈출 가능하지만, 탈출 시점에 **caller slot로 재로워링**되거나 **복사/이동으로 구체화**됨

* `KIND=2 (CALLER_SLOT)`

  * `ptr`는 “호출자(상위) 프레임이 제공한 sret/out 공간”
  * `&&`가 곧바로 “반환/인자 전달”로 이어질 때 가장 강력한 소거 패턴을 제공
  * `AUX_*`는 보통 0 (불필요)

* `KIND=3 (HEAP_BOX)`

  * v0에서는 기본적으로 “명시적 박싱 문법이 있을 때만” 생성되는 것을 권장
  * `ptr`는 헤더/박스 주소
  * (v0 철학상) “자동 힙 할당으로 도망”은 금지/비권장. 즉 `&&` 자체가 힙을 의미하지 않는다.

* `KIND=4..7` : 예약(미래 확장: shared/refcount, region, pinned, extern 등)

> 설계 의도: `ctrl`은 “런타임 동작을 바꾸는 스위치”가 아니라, **컴파일러가 소거/인라이닝을 하기 위한 증거(Proof)와 컨텍스트**다.
> 따라서 최적화 레벨이 낮아도 의미는 동일하며, 최적화 레벨이 높아질수록 `ctrl` 기반 소거가 강해진다.

---

### (3) lowering 규칙(표현식 -> IR 관점)

`&&x`는 다음 성질을 만족하도록 lowering 된다.

#### 3.1 기본 lowering(개념)

* 입력: `x`는 place expression, 정적 타입 `T`
* 출력: `handle3(ptr, meta, ctrl)`

개념적으로:

1. `ptr = address_of(x)` 또는 “move source 주소”
2. `meta = &__gpl_type_meta_T` (컴파일러 생성 정적 메타)
3. `ctrl = make_ctrl(kind=STACK_SLOT or CALLER_SLOT, has_drop=...)`

여기서 핵심은:

* `meta`는 **항상 정적으로 결정**된다.
* `ctrl.kind`는 컨텍스트 기반으로 결정된다(특히 반환/인자 전달 경로면 CALLER_SLOT로).
* 어떠한 경우에도 `&&` 자체가 “런타임 함수 호출”로 정의되지 않는다.

#### 3.2 반환 위치 최적화 기본 정책(v0 권장)

함수에서 `return &&x;` 패턴이 보이면, 컴파일러는 기본적으로:

* `x`를 **caller sret 공간에 직접 move-construct**
* 결과 handle은 `KIND=CALLER_SLOT`로 만든다.
* 이후 handle 자체는 곧바로 소거 가능(아래 최적화 케이스 참조)

---

### (4) `&&` 최적화 허용 범위(의미 보존만)

컴파일러는 아래 최적화를 허용한다(의미는 동일, 관측 불가):

* handle을 메모리 객체로 만들지 않고 레지스터/SSA 값으로만 보관
* `meta`가 정적으로 확정되면 간접 호출 대신 직접 호출/인라인
* escape 분석으로 중간 handle 생성 단계를 제거
* 즉시 파괴되는 handle 제거(dead handle elimination)
* `ctrl.kind`가 증명되면, 해당 경로로만 특수화하여 분기 제거

단, 아래는 **금지**(의미 변화):

* 어떤 경우에는 “그냥 포인터”, 어떤 경우에는 “소유 핸들”처럼 표현을 바꿔 관측 가능한 의미가 달라지는 것
* borrow를 `&&`로 승격하여 탈출시키는 것(8.3.2의 borrow 비탈출 유지)

---

### 8.3.6 컴파일러 최적화 케이스 5개 (3word 기반 소거 패턴 포함)

아래 최적화들은 모두 “의미 보존(escape handle 의미는 유지)”을 전제로 하며, 관측 가능한 런타임 효과를 추가하지 않는다.

---

#### 최적화 1) Return-by-escape: caller-slot 직접 구성 + handle 소거

패턴:

```parus
def make() -> Handle<T> {
  set x = T();
  return &&x;
}
```

lowering 핵심:

* `x`를 **caller의 반환 슬롯(sret)** 에 직접 move-construct
* 결과 handle은 `KIND=CALLER_SLOT`, `ptr = sret_ptr`
* `meta`는 상수 포인터
* `ctrl`은 상수(`CALLER_SLOT | HAS_DROP?`)

소거:

* 반환 ABI가 handle3라도, 실제로는 `ptr/meta/ctrl` 모두 상수/이미 알려진 값으로 정리되어

  * 호출자에서 즉시 “그냥 반환 슬롯을 가진 값”으로 취급 가능
  * 중간 handle 값을 **레지스터에조차 만들 필요가 없음**

---

#### 최적화 2) Forwarding escape: `&&` 생성 후 즉시 인자 전달(중간 handle 제거)

패턴:

```parus
def g(h: Handle<T>) -> void { /* ... */ }

def f() -> void {
  set x = T();
  g(h: &&x);
}
```

lowering:

* `&&x`는 `KIND=STACK_SLOT`로 생성될 수 있으나,
* 바로 호출 인자로 들어가므로 컴파일러는 `g`의 ABI에 맞춰 **직접 전달 형태로 재작성** 가능

소거:

* `&&x`라는 “중간 handle 값”을 만들지 않고,

  * `(ptr=&x, meta=&meta_T, ctrl=STACK_SLOT|...)` 를 호출 규약에 맞춰 바로 배치
* `meta`가 상수면 간접 없이 직접 경로로 최적화 가능

---

#### 최적화 3) Dead handle elimination: 즉시 파괴되는 escape 제거

패턴:

```parus
def f() -> void {
  set x = T();
  set h = &&x;
  // h를 더 이상 쓰지 않음
}
```

의미:

* handle이 생성되었으나 사용되지 않는다.
* “escape로 만들었다”는 사실 자체는 관측 불가(순수한 의미 토큰이므로).

소거:

* `h` 생성 자체를 제거하고,
* `x`는 원래 스코프 종료 시점에 파괴되므로(drop이 있다면) 원래 의미 유지

ctrl 기반 증명:

* `ctrl.kind=STACK_SLOT`이고 `h`가 외부로 전달되지 않음이 증명되면
  -> handle 생성은 100% 제거 가능

---

#### 최적화 4) Meta direct-call/inlining: meta 기반 간접 호출 제거

패턴:

```parus
def drop_it(h: Handle<T>) -> void {
  // 스코프 종료 시 드랍
}
```

일반적으로 handle drop은 “meta->drop_fn(ptr)” 형태가 될 수 있다.

하지만 v0에서:

* `meta`는 정적으로 확정된 `&__gpl_type_meta_T`
* `drop_fn`도 정적 주소(또는 null)

최적화:

* `meta` 역참조를 제거하고 `drop_T(ptr)`로 **직접 호출**
* trivial drop이면 호출 자체를 제거 (`HAS_DROP=0` 또는 meta flag 기반)

ctrl 연계:

* `ctrl.HAS_DROP=0`이면 drop 경로는 완전히 제거 가능
* `KIND=CALLER_SLOT`이면 drop 책임이 “해당 스코프에 있는지”도 더 쉽게 결정됨(특수화)

---

#### 최적화 5) Stack-slot -> caller-slot 재로워링: 탈출 시점에서만 구체화

패턴:

```parus
def pass() -> Handle<T> {
  set x = T();
  set h = &&x;     // 여기서는 STACK_SLOT
  return h;        // 여기서 탈출
}
```

v0 기본 lowering:

* 처음 `h`는 `(ptr=&x, meta=meta_T, ctrl=STACK_SLOT|...)`

탈출 시점 최적화:

* 반환 경로에서 `x`를 caller-slot에 직접 move-construct
* `h`를 새로 만들지 않고, `ctrl.kind`를 `CALLER_SLOT`로 “재로워링”
* `STACK_SLOT` handle은 결과적으로 소거되고, 최종 결과는 return-by-escape와 동일한 형태가 됨

핵심:

* 힙 할당 같은 런타임 전략으로 도망치지 않고,
* **탈출 경계에서만** out-slot으로 구체화하여 “0 오버헤드”를 유지한다.

---

### 8.3.7 제약 재확인 (v0 고정)

* `&` / `&mut` / `&&` 는 place expression에만 적용 가능
* borrow(`&T`, `&mut T`, `&[T]`, `&mut [T]`)는 절대 탈출 불가
* `&&`는 borrow에 적용 불가
* 논리 연산은 `and/or/not/xor` 키워드만 사용 (`&&`는 escape 예약)
* `pure` / `comptime`과 `&&` 결합 규칙은 v0에서 상세를 보류한다.

---

#### (부록) 타입 표기 관련 주의(v0)

* 기존 C 스타일 이름 `int`, `float` 등은 금지(컴파일러 빌트인에 해당 타입 없음)

  * 정수는 `i32`, `i64` 등
  * 부동소수는 `f32`, `f64` 등
* `text`는 빌트인 문자열 슬라이스 타입으로 항상 사용 가능
* `String`은 표준 라이브러리 타입이며, std 링크가 없으면 사용할 수 없다
* null 가능 타입 표기는 `T?`로 하며, `&i32?`는 허용한다.

  * 우선 파싱 규칙은 “타입 접미 `?`가 `&`보다 우선 결합”으로 둔다: `&i32?`는 `&(i32?)`로 해석
  * 다른 해석을 원하면 괄호로 명시한다: `(&i32)?` 또는 `&(i32?)`

(이 파싱/우선순위 규칙은 8.2 타입 문법 섹션에서 최종 고정한다.)

### 8.3.8 `&&` 장수명(escaping)과 `static` 저장소 연계

`&&`는 “소유권을 탈출 가능한 handle3로 승격”하지만, v0에서 `&&` 자체가 힙 할당이나 암묵 런타임 호출을 발생시키지 않으므로, **탈출한 값이 어디에 저장되는지(storage)** 가 명확해야 한다. 이 섹션은 `&&`가 “장수명”으로 사용되는 경우에, 저장소를 `static`/`unique`와 어떻게 연계하는지에 대한 v0 지침을 고정한다.

#### (1) v0 핵심 원칙: “장수명 `&&`는 장수명 place에서만”

v0에서 `&&x`의 대상 `x`는 place expression이어야 하며, 그 place는 아래 중 하나여야 한다.

* **경계 직결(caller-slot)**: `return &&x;`, `f(arg: &&x)`처럼 `&&`가 곧바로 반환/인자 전달로 이어져 컴파일러가 `KIND=CALLER_SLOT`로 lowering 할 수 있는 경우
* **정적 저장소(static place)**: `static`으로 선언된 전역/정적 place(프로그램 수명)인 경우
* (선택, v0 확장) **고정 풀(pool place)**: 구현이 제공하는 정적 풀 슬롯(이 문서에서는 기본 규칙만 다룬다)

이 원칙은 다음을 보장한다.

* 힙/런타임이 없는 freestanding에서도 `&&`가 안전하게 동작한다.
* “스택 슬롯을 가리키는 handle이 함수 밖으로 나가서 dangling” 되는 구조를 원천 차단한다.

#### (2) `static` place에서의 `&&`: 장수명 탈출의 기본 해법

`static`으로 선언된 place는 프로그램 수명 동안 유효하므로, 다음 패턴은 v0에서 장수명 `&&`의 표준적인 형태다.

```parus
static mut G: i32 = 7i32;

def get_g() -> Handle<i32> {
  // G는 static place이므로 &&로 탈출 가능
  return &&G;
}
```

권장 규칙(v0):

* `&&`가 “장수명으로 사용”되는 경로(반환/저장/캡처 등)에서, 대상 place가 `static`이 아니면 컴파일 에러로 보고한다.
* 단, `return &&x;` 같은 caller-slot 최적화 경로는 예외로 허용한다(스택에 남지 않으므로).


여기서 중요한 점:

* `static`은 “유일 소유”를 **컴파일 타임 규칙으로 고정**한다.
* `&&`는 힙/암묵 호출이 없으므로, “take 결과를 장수명으로 저장”하려면

  * `return &&u;`처럼 caller-slot 경계로 넘기거나,
  * 정적 place 자체를 `&&`로 넘기는 형태(`return &&UART0;`)를 사용해야 한다.

#### (3) nullable(`T?`)와 take(consume) 표준 패턴(v0 권장)

* (권장 A) 컴파일러 내장: `unwrap_move(place: T?) -> T`

  * 전제: `place != null`
  * 동작: `T` 값을 소유로 꺼내고, 원본 place는 `null`로 만든다(consume).
* (권장 B) v0 표준 라이브러리(단, no-std에서도 제공 가능한 “core” 레벨로 배치)

예시(권장 A 형태):

```parus
unique static mut LOG: Logger? = null;

def take_log() -> Handle<Logger> {
  if (LOG == null) { throw Error::from_code(code: 2); }
  set v = unwrap_move(LOG);
  return &&v; // caller-slot
}
```

이 패턴은 다음을 만족한다.

* `static` 초기화는 항상 상수(`null`)로 가능
* 초기화/해제/재초기화가 명시적
* `unique` moved-out 모델과 자연스럽게 일치

#### (4) 저장/캡처/전역 보관 시의 규칙(핵심 제약)

borrow(`&T`, `&mut T`, slice borrow 등)는 8.3.2 규칙에 의해 저장/캡처/반환이 금지된다. 장수명 보관을 하고 싶다면 `&&`를 사용해야 한다. 단, v0에서 `&&`는 힙으로 도망치지 않으므로 다음을 강제한다.

* 장수명 보관 대상이 되는 `&&x`에서 `x`는:

  * (A) caller-slot 경계로 즉시 넘어가거나, 또는
  * (B) `static`(또는 구현이 허용한 pool/region) place여야 한다.

금지 사례(의도 설명):

```parus
def bad_escape_store() -> void {
  set x = T();

  set h = &&x;
  // 여기서 h를 전역/컨테이너/클로저에 저장하려 하면:
  // x는 스택 place이므로 함수 종료 후 dangling이 된다.
  // 따라서 v0에서는 "장수명 저장" 컨텍스트에서 &&x를 허용하지 않는다.
}
```

권장 진단 메시지(v0):

*error: escaping handle requires long-lived storage (static/pool/region or caller-slot).
help: move value into a static/pool slot, or return it directly (return-by-escape), or use std::Handle<T> (heap-capable) when available.*

#### (6) no-std/freestanding에서의 실무 패턴 요약

v0(no-std)에서 “장수명”을 만드는 기본 패턴은 아래 둘로 정리된다.

1. **전역 유일 자원**: `static T? = null` + `init()` + `take()`(unwrap_move) + `return &&local`(caller-slot)
2. **다수 리소스**: `static` 풀/테이블(고정 배열) + ID 보관 + 접근 시 `&`/`&mut`로 잠깐 빌림
   *(풀/ID 패턴은 storage 문서 또는 별도 섹션에서 확장)*

이 섹션의 목적은 `&&`가 힙 없이도 “경계와 저장소”를 통해 장수명 의미를 유지하도록 하는 것이다.

---

### 8.4 slice borrow: `&[T]`, `&mut [T]` 와 슬라이싱 문법

Parus은 Rust 스타일의 slice/view 표현력을 원하지만, 표준 라이브러리 특수 타입(view<T>)에 언어 규칙을 붙이면 “코어/표준 경계”가 흐려질 수 있다.
따라서 v0에서는 slice를 **언어 코어의 borrow 타입 확장**으로 직접 제공한다.

#### (1) slice 타입 정의

* `&[T]` : 읽기 전용 slice borrow
* `&mut [T]` : 쓰기 가능 slice borrow(배타적)

slice borrow는 일반 borrow와 동일한 성질을 가진다.

* **비탈출(non-escaping)**: 반환/저장/캡처/FFI 전달/`&&` 승격 금지
* **렉시컬 수명**: 블록 스코프 기반
* **배타 규칙**: `&mut [T]`가 살아있는 동안 같은 base에 대한 다른 접근 제한

#### (2) 슬라이싱(slicing) 문법: `&x[a..b]`, `&x[a..:b]`

슬라이싱은 “값을 꺼내서 뭘 한다”가 아니라, 그 자체가 **하나의 조작(권한+범위) 생성**으로 인식된다.

권장 문법(최소 형태):

* `set s = &x[a..b];`
* `set s = &x[a..:b];`
* `set s = &mut x[a..:b];`

여기서 `x`는 다음 중 하나여야 한다(v0):

* 고정 배열 `T[N]`
* (선택) 가변 리스트 `T[]` — v0에서 리스트가 들어오면 동일 규칙 적용 가능

범위 규칙은 기존 range와 동일:

* `a..b` : b 미만
* `a..:b` : b 이하

#### (3) 결과 타입 규칙

* `&x[a..b]`의 타입은 `&[T]`
* `&mut x[a..b]`의 타입은 `&mut [T]`

여기서 `T`는 `x`의 요소 타입이다.

#### (4) 기본 제약(단순하고 강한 v0 규칙)

* 인덱스 `a`, `b`는 정수 타입이어야 한다(v0에서는 int 계열로 고정 권장).
* `a`, `b`의 런타임 범위 검사는 구현 선택:

  * v0 권장: debug 빌드에서만 검사 + release에서는 제거 가능(또는 최소 검사)
* slice는 **항상 비탈출**이므로, “slice를 반환하고 싶다”면 반드시 복사/핸들을 사용해야 한다:

  * 작은 데이터면 `return copy ...;`
  * 큰 데이터면 표준 handle 타입을 사용(또는 API 설계를 바꾸기)

#### (5) 예시: 요청한 형태 그대로

```parus
def slice_demo() -> void {
  let x: int[8] = [0,1,2,3,4,5,6,7];

  // 슬라이스 생성(읽기 전용)
  set arr = &x[1..:5];     // 타입: &[int]  (요소: 1,2,3,4,5)

  // 슬라이스 생성(쓰기 가능)
  let mut y: int[8] = [0,0,0,0,0,0,0,0];
  set win = &mut y[2..:4]; // 타입: &mut [int] (요소 슬롯: y[2],y[3],y[4])

  // 금지: slice 탈출
  // return arr;           // error: &[T]는 비탈출
  // return &&arr;         // error: borrow를 escape로 승격 금지
}
```

#### (6) 함수 파라미터에서의 사용 예시

```parus
def sum(xs: &[int]) -> int {
  set mut s = 0;
  // v0에서는 slice 반복을 단순화하기 위해 표준 라이브러리 helper가 필요할 수 있음
  // 최소 구현: xs[i] 인덱싱을 허용(범위 내라고 가정하거나 디버그 검사)
  set mut i = 0;
  while (i < xs.len) {     // len 접근 문법은 v0에서 선택: 내장 또는 표준 규약
    s = s + xs[i];
    i = i + 1;
  }
  return s;
}

def use_sum() -> void {
  let a: int[6] = [10,20,30,40,50,60];
  set mid = &a[1..:4];     // &[int] (20,30,40,50)
  set r = sum(xs: mid);
}
```

> 구현 메모(v0): `&[T]`는 내부적으로 `(ptr, len)` 형태의 borrow 값으로 lowering 하면 된다.
> 이는 “표준 라이브러리 특수 타입”이 아니라 **언어 코어 타입**이므로 freestanding에서도 경계가 깨지지 않는다.

### 8.5 `copy` / `clone` 연산자(키워드) 정의

Parus은 “암묵 복사 금지(또는 최소화)”를 목표로 하므로, 복사/복제는 **연산자(키워드)로 명시**한다.
`copy()` / `clone()` 같은 함수 형태는 제공하지 않는다(유저 라이브러리 함수처럼 보여 언어 철학과 충돌).

#### (1) 문법(권장): prefix 연산자

* `copy Expr`
* `clone Expr`

우선순위: 단항 연산자 레벨(예: `not`, unary `-`)과 동일하게 취급한다.
즉, `copy a + b`는 `(copy a) + b`로 해석된다(혼동 방지를 위해 괄호를 권장).

#### (2) 의미론

* `copy` : **얕은 복사(shallow copy)**, 값의 “비트 단위 복사”에 가까운 복사

  * POD(field) 및 기본 수치 타입처럼 “복사 비용과 의미가 명확한 타입”에 적합
* `clone` : **깊은 복사(deep clone)**, 소유 리소스가 있으면 새로 복제

  * string, handle 기반 컨테이너, 리소스 객체 등

v0 권장 정책:

* `copy`는 “Copy 가능 타입”에서만 허용
* `clone`은 “Clone 가능 타입”에서만 허용

#### (3) 타입체커 규칙(acts 연동)

`copy Expr` / `clone Expr`는 다음처럼 처리한다.

1. Expr의 타입을 T로 확정한다.
2. `acts T`에서 다음 op를 찾는다.

   * `op(copy)`  (copy용)
   * `op(clone)` (clone용)
3. 정확히 1개가 매칭되면 그 반환 타입이 결과 타입이다(일반적으로 T).
4. 없으면 에러.

즉, `copy/clone`은 “언어 내장 매직”이 아니라 **acts의 op 매핑으로 표준화**된다.
(단, 기본 수치 타입/단순 field에 대해서는 컴파일러가 내장 acts를 제공해도 된다.)

#### (4) place 요구 여부(v0 권장)

v0에서는 단순화를 위해 아래 중 하나를 선택한다(둘 다 가능하지만, v0는 하나로 고정 추천).

* 정책 A(단순/보수): `copy/clone`은 place expression에만 허용

  * `copy x` ok, `copy (a+b)` error
* 정책 B(표현력): rvalue도 허용

  * `copy (a+b)` ok (임시값 복사)

Parus의 “명시적 비용” 철학상 정책 A가 더 보수적이고 구현도 쉽다.

#### (5) 예시(반환/대입/초기화)

```parus
def demo_copy_return(a: int) -> int {
  // int는 내장 copy 가능
  return copy a;
}

def demo_copy_assign() -> void {
  let x: int = 3;
  let y: int = copy x;   // 명시적 복사
}

def demo_clone_assign() -> void {
  let s: string = "hi";
  let t: string = clone s;   // 깊은 복제(새 버퍼)
}
```

#### (6) 경고

컴파일러는 `copy` 사용에 대해 휴리스틱 경고를 낼 수 있다.

예:

* 큰 배열/큰 field를 `copy`로 통째로 복사하려는 경우
* 반복문에서 큰 값을 `copy`로 계속 생성하는 경우

이 경고는 오류가 아니라 “비용 경고”로 둔다.

#### (7) acts 예시: 사용자 정의 타입의 copy/clone

```parus
field Big {
  u32 a;
  u32 b;
  u32 c;
  u32 d;
}

acts for Big {
  operator(copy)(self) -> Big {
    // field는 POD이므로 단순 복사로 충분
    return __intrin_memcpy_big(x: self);
  }
}
```

### 8.6 `delete` 문장(명시적 파괴) 정의

`delete`는 스코프 기반 파괴(RAII)를 기본으로 하되, “리소스를 지금 당장 닫고 싶다” 같은 경우를 위해 제공한다.
(예: 파일 핸들 조기 해제, GPU 리소스 조기 반환)

#### (1) 문법

* `delete place;`

`delete`는 **문장(statement)** 이다. 표현식이 아니다.

#### (2) 의미론

* `delete x;`는 x를 **소비(consumed)** 하며, 이후 x는 사용 불가이다.
* `delete`는 내부적으로 `acts T`의 `op(drop)` 또는 class destructor/handle drop으로 lowering 된다.

권장 lowering:

* `delete x;`  ==>  `__drop(T, x)` 또는 `acts T op(drop)`

#### (3) 적용 대상(v0 권장)

v0에서 구현 난이도를 낮추기 위해 다음처럼 제한을 권장한다.

* 허용: `&&`로 생성된 handle(escape 소유 객체), 또는 명확한 소유 객체(class 값)
* 금지: borrow(`&T`, `&mut T`, `&[T]`, `&mut [T]`)에 대한 delete
* `pure` / `comptime` 문맥에서의 `delete` 제약은 v0에서 상세를 보류한다.

> 주의: class 생성자/소멸자 삭제 문법의 `= delete;`는 “선언” 문맥이고,
> 여기의 `delete x;`는 “문장” 문맥이다. 둘은 충돌하지 않는다.

### 8.7 연산자 전반의 acts op 매핑 확장 지침(표준 키 목록)

표현식에서 사용하는 연산자 대부분은 `acts`의 `op(...)`로 해석 가능해야 한다.
v0에서 구현을 튼튼하게 만들기 위해, **op 키 문자열을 표준화**한다.

#### (1) v0 표준 op 키(권장)

이 목록은 “문법 토큰”과 “op 키”를 1:1로 연결하기 위한 최소 표준이다.

* 산술: `op(+)`, `op(-)`, `op(*)`, `op(/)`, `op(%")`
* 비교: `op(==)`, `op(!=)`, `op(<)`, `op(<=)`, `op(>)`, `op(>=)`
* 논리(키워드 기반): `op(and)`, `op(or)`, `op(not)`, `op(xor)`
* 단항: `op(-unary)`, `op(not)(또는 not와 통일)`
* 복사/복제: `op(copy)`, `op(clone)`
* 파괴: `op(drop)`
* 증감(v1+ 확장 키 예시): `op(++pre)`, `op(++post)` 등

v0에서는 증감(++/--)을 기본 수치 타입에 내장으로 제공해도 되며,
장기적으로는 위 확장 키로 acts에 편입 가능하다.

#### (2) 규칙

* 동일 타입의 acts 블록에서 같은 `op(...)`는 **정확히 1개만** 허용한다.
* 여러 후보가 생기면 모호성 에러(ambiguous)로 보고한다.

#### (3) 예시: copy/clone/drop까지 포함한 acts

```parus
acts string {
  def do_clone(self) : op(clone) -> string { return __intrin_string_clone(s: self); }

  def drop(self) : op(drop) -> void { __intrin_string_drop(s: self); }
}
```

### 8.8 예외 메커니즘: `throw`, `try...catch`, 예외 타입, 전파 규칙 (추가)

### 8.8.1 예외 값의 타입: 표준 `Error`만 허용(v0 고정)

Parus의 `throw`는 “아무거나 던지기”를 금지한다. v0에서는 다음으로 고정한다.

* `throw`에 실리는 값은 반드시 표준 라이브러리의 `Error` 타입이어야 한다.

  * 권장: `Error`는 “메시지 + 코드 + 원인 체인”을 담을 수 있는 불투명 핸들
  * freestanding에서도 동작 가능하도록 `Error`는 **할당 없이도 생성 가능한 경로**(고정 문자열, 코드 기반)를 제공해야 한다.

예시(표준 라이브러리 관례 예시):

```parus
// std::error::Error 가 있다고 가정
use std::error::Error;

def fail?( ) -> void {
  throw Error::from_msg(msg: "boom");
}
```

---

### 8.8.2 `throw` 문장 규칙(? 함수 전용)

* `throw Expr;` 는 **문장(statement)** 이다.
* **? 함수 내부에서만 허용**된다.
* Expr의 타입은 `Error`여야 한다(또는 `Error`로의 명시적 변환이 있어야 한다).

```parus
def read_file?(path: string) -> bytes {
  if (path == "") {
    throw Error::from_code(code: 12);   // ok
  }
  // ...
}
```

---

### 8.8.3 `try...catch` 문법과 규칙(? 함수 전용)

문법(권장 최소형):

```parus
try {
  // throwing code
} catch (e: Error) {
  // handler
}
```

규칙:

* `try...catch`는 **? 함수 내부에서만 허용**
* catch 파라미터 타입은 v0에서 `Error`로 고정(패턴/다형 catch는 v1+)

예시:

```parus
def load_user?(id: u32) -> User {
  try {
    return fetch_user?(id: id);
  } catch (e: Error) {
    // 복구 또는 변환
    throw Error::wrap(msg: "load_user failed", cause: e);
  }
}
```

---

### 8.8.4 전파 규칙(암묵 전파)과 “명시성”의 경계

? 함수는 예외를 암묵 전파할 수 있다. 단, non-?로 빠져나가는 경계에서는 항상 명시적이어야 한다.

* `? -> ?` : 암묵 전파 허용
* `? -> non-?` : 직접 호출 금지(6.X.2), 반드시 `attempt`로 값으로 포획

이 규칙 덕분에 컴파일러는 **non-? 영역을 강한 최적화/단순 CFG**로 유지할 수 있다.


---
