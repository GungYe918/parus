## 10. Type Declarations (field/proto/class)

문서 상태: `Normative (Proto v1: Constraint-Only)`

### 10.1 field

1. `field`는 데이터 선언이다.
2. `field`는 `proto`를 구현 대상으로 가질 수 있다.
3. `field`에서 `proto`를 구현할 때, 요구 멤버 함수가 존재하면 현재 v1에서는 충족할 수 없으므로 타입체크 오류가 발생한다.

예시:

```parus
field UserId : Marker {
  u64 value;
}
```

### 10.2 proto (constraint-only)

1. `proto`는 제약/계약 선언 전용이다.
2. `proto`는 런타임 엔티티를 생성하지 않는다(완전 소거).
3. 연산자 의미 변경은 금지된다. 연산자 규칙은 `acts` 전용이다.
4. `proto` 본문에는 함수 시그니처만 허용된다.
5. `proto` 멤버 함수는 본문이 없어야 한다.
6. `proto` tail은 `with require(<expr>)`를 반드시 가져야 한다.

기본 문법:

```parus
proto Equatable {
  def eq(self, rhs: &Self) -> bool;
} with require(true);
```

### 10.3 self / Self 규칙

1. `Self`는 proto 구현체 타입 플레이스홀더다.
2. `Self`는 타입 위치에서 사용한다.
3. `self`는 함수 리시버 위치에서 사용한다.
4. proto 멤버 시그니처에서도 `self`, `self mut`, `Self`, `&Self`를 사용할 수 있다.

### 10.4 require(expr) v1 규칙

1. `require(expr)`는 bool 식만 허용된다.
2. v1 허용식:
3. `true`, `false`
4. `!`, `&&`, `||`
5. 괄호
6. v1 금지식:
7. 함수 호출
8. 이름 참조
9. 매크로 호출
10. 멤버 접근

예시:

```parus
proto Buildable {
  def build(self) -> void;
} with require(true && !false);
```

### 10.5 class

1. `class`은 구현체 타입이다.
2. `class Name : ProtoA, ProtoB` 형태로 proto 구현을 명시한다.
3. 타입체커는 `class`이 요구 시그니처를 충족하는지 검사한다.

예시:

```parus
proto Equatable {
  def eq(self, rhs: &Self) -> bool;
} with require(true);

class User : Equatable {
  let id: i32;

  def eq(self, rhs: &Self) -> bool {
    return true;
  }
}
```

