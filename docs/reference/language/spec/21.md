## 10. 타입 정의: field, proto, tablet, 접근 제한자

> OOP/다형성 규칙의 정본은 `docs/reference/abi/v0.0.1/OOP_MODEL.md`다.
> 본 장은 구현 편의를 위한 요약이며, 충돌 시 OOP 모델 문서를 우선한다.

### 10.1 field (POD storage)

정의:

* field는 POD 데이터 블록이다.
* 생성자/소멸자 없다.
* field 내부에는 값만 있다. 함수 선언/정의 금지.
* field는 tablet/class 내부에 포함 가능하다.
* proto 내부 저장 field는 v0에서 금지한다(함수 계약으로 표현).
* field는 기본적으로 copy 가능 조건을 가진다. (모든 멤버가 copy 가능일 때)

field 리터럴/초기화 규칙 (v0):

* 생성 문법: `TypePath{ name: expr, ... }`
* 모든 멤버를 반드시 명시 초기화해야 한다.
  * 누락 멤버: 컴파일 오류
  * 중복 멤버: 컴파일 오류
  * 존재하지 않는 멤버: 컴파일 오류
* `TypePath{}`는 멤버 수가 0인 field에서만 허용한다.
* optional 멤버(`T?`)도 생략은 불가하며 `name: null`을 명시해야 한다.
* non-optional 멤버에 `null`을 넣으면 컴파일 오류다.
* `field` 멤버 선언에는 `mut`를 도입하지 않는다.
  * 가변성은 바인딩에서만 표현한다 (`let mut v: Vec2 = ...; v.x = ...;`)
* `layout(c)` field 멤버에는 optional(`T?`)을 허용하지 않는다.

추가 (field 타입 제한 파라미터, 추가):

* field는 선택적으로 타입 파라미터/제약을 가질 수 있다.
* 문법 예:

  * field<T> Name { ... }
  * field<u32, i32> Name { ... }
  * field<typename T> Name { ... }  // v1+ 목표 형태, v0에서는 파싱만 선행 가능
* 의미:

  * field<u32, i32> D { ... } 는 "D가 담을 수 있는 멤버 타입의 후보를 제한"하는 선언으로 해석한다.
  * v0에서는 가장 단순하게 "field 본문에서 등장하는 타입이 <> 목록에 포함되어야 한다"로 시작할 수 있다.
  * 향후에는 "특정 슬롯이 오직 해당 타입만 허용" 같은 더 세밀한 제약으로 확장 가능하다.

허용 멤버 (v0):

* 수치, bool, char
* 고정 배열 T[N] (T가 POD)
* 다른 field
* Handle<T> (표준 라이브러리 타입, 설계 포함)

금지 (v0):

* string (가변/복잡 소유권)
* T[] (가변 리스트)
* class 인스턴스
* &T, &mut T (borrow 참조)
* closure<...>

예시

```parus
field Vec2 {
  float32 x;
  float32 y;
}

field Particle {
  Vec2 pos;
  Vec2 vel;
  uint32 id;
}
```

예시 (타입 제한 field, 추가)

```parus
field<u32, i32> OnlyInts {
  u32 a;
  i32 b;
  // float32 c; // error: field<>에 포함되지 않은 타입
}
```

### 10.2 proto (interface only)

정의:

* `proto`는 인터페이스 계약(시그니처 집합)이다.
* 생성자/소멸자/구현 본문을 갖지 않는다.
* 연산자 재정의는 `proto`가 담당하지 않는다. (`acts` 전용)
* v0에서 `proto`는 정적 디스패치 계약으로 사용한다(`dyn` 미도입).

핵심 규칙(v0):

1. `proto` 본문에는 함수 시그니처만 선언한다.
2. `proto` 안의 저장 field 선언은 금지한다(v0 단순화).
3. `proto`는 다른 `proto`를 상속(확장)할 수 있다.
4. 구현 권한:
   * v0: `tablet`만 `proto`를 구현할 수 있다.
   * v1+ 확장 후보: `field`의 제한적 구현 허용
   * `class`는 상태머신 보호를 위해 구현 대상에서 제외 권장

`Self` 규칙:

* `proto` 안에서 `Self`는 "해당 `proto`를 구현하는 구체 타입"을 뜻한다.
* `Self`는 타입 위치에서만 사용한다.

예시:

```parus
proto Drawable {
  def draw(self, ctx: &mut RenderCtx) -> void;
}
```

proto 상속(확장) 예시:

```parus
proto Hashable {
  def hash(self) -> u64;
}

proto Equatable {
  def eq(self, b: &Self) -> bool;
}

proto Keyable : Hashable, Equatable {
  def key_id(self) -> u64;
}
```

### 10.3 tablet (implementation type)

정의:

* `tablet`은 구현체 타입이다. (생성자/소멸자 + 메서드 + proto 구현)
* 표기: `tablet Name [: Proto1, Proto2, ...] { ... }`
* v0 권장: **상속은 proto에 대해서만 허용**한다.

  * `tablet`끼리의 상속(필드/레이아웃 상속)은 v1+로 미룬다. (ABI/생성자 체인이 복잡해짐)

예시

```parus
proto Drawable {
  def draw(self, ctx: &mut RenderCtx) -> void;
}

tablet Sprite : Drawable {
    let pos: Vec2;

    def draw(self, ctx: &mut RenderCtx) -> void {
      // ...
    }
}
```

---

### 10.3.1 멤버 구성 규칙 (v0)

* `tablet` 본문은 멤버 목록으로 구성한다.
* 멤버 종류(v0):
  * 데이터 멤버: `let name: Type;` / `let mut name: Type;`
  * 메서드: `def ... { ... }`
  * 생성자/소멸자: `init`, `deinit` (아래 10.3.3)
* `public:` / `private:` 접근 라벨은 v0에서 보류한다.
  * 문법은 아직 정식 확정하지 않는다.
  * 접근제어 모델은 tablet 설계 문서 확정 시 별도로 고정한다.

예시

```parus
tablet A {
  let x: int;
  def get_x(self) -> int { return self.x; }
  def helper(self) -> void { ... }
}
```

---

### 10.3.2 메서드의 `self` 규칙 (v0 단순/강제)

Parus은 borrow 설계가 있기 때문에, 메서드의 수신자(receiver)를 **명시적으로 단순화**한다.

* `tablet` 내부의 `def name(...) -> R { ... }` 는 **항상 인스턴스 메서드**다.
* 메서드에는 암묵 수신자 `self`가 존재한다.
* v0에서 수신자 표기는 아래 둘만 허용한다.

  * `self` : `&Self` (기본, 읽기 전용)
  * `self mut` : `&mut Self` (가변)

* `self move`는 v0에서 보류한다.
* `def mut` 문법은 v0에서 사용하지 않는다.

예시

```parus
tablet Counter {
    let mut n: int;

    def get(self) -> int {
      return self.n;
    }

    def inc(self mut) -> void {
      self.n += 1;
    }
}
```

추가 규칙(v0):

* `self`는 예약 식별자다(키워드 취급 권장).
* `pure/comptime` 제약 상세는 v0에서 보류한다. (6.2 참조)

---

### 10.3.3 생성자/소멸자: `init`, `deinit` (v0 단일 정의 규칙)

일반 함수 오버로딩은 허용한다. 다만 v0 단순화를 위해 생성자/소멸자는 타입당 단일 정의만 허용한다.

* 생성자(선택):

  * `def init(params...) -> void { ... }`
* 소멸자(선택):

  * `def deinit() -> void { ... }`

호출/동작:

* `set x = T(args...)` 는 `T.init(args...)`를 호출해 `x`를 초기화한다.
* 스코프 종료 시 `deinit()`가 호출된다(존재한다면).
* `def init(...) = delete;` 로 생성을 금지할 수 있다.
* `def deinit() = delete;` 는 v0에서는 **금지 권장**(파괴 금지 객체는 모델이 꼬임). 대신 “drop이 없는 handle” 같은 타입으로 해결.
* 구현 전환기에서는 내부 lowering을 `construct`/`destruct`로 대응시킬 수 있다.
  * 문서/예제 표면 문법은 `init`/`deinit`를 기준으로 한다.

예시

```parus
tablet File {
    let fd: int;

    def init(path: string) -> void {
      // open...
    }

    def deinit() -> void {
      // close...
    }
}
```

---

### 10.3.4 proto 구현 규칙(정적 검사, v0 고정)

* `tablet X : ProtoA, ProtoB` 는 “X가 각 proto의 모든 메서드를 구현해야 함”을 뜻한다.
* 구현 체크는 prepass 이후 타입체커 단계에서 수행한다.
* proto 상속이 있을 경우, 조상 proto의 요구사항까지 전부 폐쇄(closure)해 검사한다.
* 시그니처 일치 조건(v0):

  * 함수명 동일
  * 파라미터 타입 동일
  * 반환 타입 동일
  * receiver kind 동일 (`self` vs `self mut`)
  * `? 함수` 여부는 **proto에서는 v0 금지 권장**
    (예외 전파가 인터페이스 경계를 넘으면 ABI/최적화 모델이 확 흔들림)

---

### 10.3.5 proto 값/참조/핸들 사용 규칙(동적 디스패치 경계)

v0에서 proto는 “값으로 들고 다니는 타입”이 아니라 **참조/핸들로만 쓰는 계약**으로 고정하는 게 안전하다.

권장 규칙(v0):

* `ProtoType` 자체를 값으로 선언 금지:

  * `let d: Drawable;` 금지
* 허용:

  * `&Drawable` (non-escaping borrow로서의 다형성)
  * `handle<Drawable>` (escape 가능한 다형성)
* 업캐스트는 암묵 허용:

  * `handle<Sprite>`를 `handle<Drawable>` 파라미터에 전달 가능
  * `&Sprite`를 `&Drawable` 파라미터에 전달 가능

이 모델은 네가 이미 정의한 `handle`의 `(ptr, meta)` ABI와 잘 맞는다.

* `meta`를 “vtable 포인터”로 쓰면 된다.

`dyn` 통합 방향(v1+):

1. `dyn Proto`를 명시 opt-in으로 도입한다.
2. 기본 경로는 계속 정적 디스패치(제네릭 + 제약)다.
3. `dyn` 경계에서는 간접 호출/vtable 비용을 허용하되, API에서 명시적으로 드러나야 한다.

---

