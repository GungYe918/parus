## 10. Type Declarations (field/proto/class)

문서 상태: `Normative (Proto v1: Constraint-Only)`

### 10.1 field

1. `field`는 데이터 선언이다.
2. `field`는 `proto` 구현 대상으로 선언될 수 있다.
3. `field`는 함수 멤버를 가지지 않으므로, 필수 proto 멤버가 있으면 충족 불가 오류가 발생한다.

예시:

```parus
field UserId : Marker {
  u64 value;
}
```

### 10.2 proto (constraint-only)

1. `proto`는 제약/계약 선언 전용이다.
2. `proto`는 런타임 엔티티를 생성하지 않는다(완전 소거).
3. `proto` 멤버는 함수 선언만 허용한다.
4. `proto` 멤버 본문은 all-or-none 규칙을 따른다.
5. `with require(...)`는 생략 가능하며 생략 시 `require(true)`로 처리한다.

기본 문법:

```parus
proto Equatable {
  def eq(self, rhs: &Self) -> bool;
};
```

### 10.3 self / Self 규칙

1. `Self`는 proto 구현체 타입 플레이스홀더다.
2. `Self`는 타입 위치에서 사용한다.
3. `self`는 함수 리시버 위치에서 사용한다.
4. 시그니처 매칭 시 `Self`/`&Self`는 구현체 타입 기준으로 정규화한다.

### 10.4 require(expr) v1 규칙

1. 파서는 `require(...)`에 일반 표현식을 허용한다.
2. 타입체커는 v1에서 단순 컴파일타임 bool 식만 허용한다.
3. 허용 연산: `not`/`!`, `and`, `or`, 괄호, `true`/`false`.
4. 비교식/매크로 프레디킷 평가는 차기 라운드에서 확장한다.

예시:

```parus
proto Buildable {
  def build(self) -> void;
} with require(true and not false);
```

### 10.5 class

1. `class`은 구현체 타입이다.
2. `class Name : ProtoA, ProtoB` 형태로 proto 구현을 명시한다.
3. 필수 proto 멤버(본문 없는 선언)만 구현 강제 대상이다.
4. proto 기본 구현(본문 있는 선언)은 class에서 생략 가능하다.
5. lifecycle 멤버는 `init(...) { ... }`, `deinit() { ... }`, `init() = default;`, `deinit() = default;`를 지원한다.
6. `init()/deinit()`은 `->` 반환 타입을 선언하지 않는다.
7. `init()/deinit()`에서는 사용자 소스에서 `self` 리시버를 선언하지 않는다.
8. lifecycle 함수 내부 ABI는 hidden receiver `self: &mut Self`를 자동 주입한다.
9. `init()/deinit() = default;`는 무인자 사용자 시그니처만 허용한다.
10. `A(...)`는 class `A`의 `init(...)` 오버로드를 호출하는 생성식이다(v0: tmp storage 생성 후 `init(..., self=&mut tmp)` 호출).
11. `init/deinit` 직접 호출(`a.init(...)`, `a.deinit()`, `A::init(...)`, `A::deinit(...)`)은 금지된다.
12. dot 호출 `a.m(...)`은 첫 파라미터가 `self`인 메서드만 허용한다.
13. class/proto 멤버 경로 호출 `A::m(...)`, `Proto::m(...)`는 제거되며, 값 dot 호출을 사용한다.
14. class 인스턴스 필드 선언은 `name: Type;`만 허용한다.
15. class 내부 `let/set/mut` 멤버 선언은 제거되며 하위호환을 제공하지 않는다.
16. 인스턴스 필드 초기화식(`name: Type = expr;`)은 허용하지 않는다.
17. class 정적 멤버는 `static def ...`와 `static name: Type = expr;`를 지원한다.
18. `static mut`은 v0에서 지원하지 않는다.
19. nested drop glue는 v0에서 미구현이며, `deinit` 대상 class를 class 인스턴스 필드로 포함하는 선언은 금지한다.

예시:

```parus
proto Widget {
  def id(self) -> i32 {
    return 1i32;
  }
};

class Button : Widget {
  value: i32;
}
```

```parus
class User {
  init() = default;
  deinit() = default;

  def id(self) -> i32 {
    return 7i32;
  }
}

def main() -> i32 {
  set u = User();
  return u.id();
}
```

### 10.6 dyn (문서 고정, 비구현)

1. 런타임 동적 디스패치/업캐스팅 경계는 `dyn`으로 명시한다.
2. 현재 라운드에서는 `dyn`을 파서/타입체커/IR에 구현하지 않는다.
3. ABI 고정 이후 별도 라운드에서 도입한다.
