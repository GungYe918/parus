## 6.1 함수 선언 기본형 (확장판, v0 기준)

Parus의 함수는 **(1) 선언 형식이 단순**하면서도, **(2) 호출 해소가 100% 정적(컴파일 타임)**으로 끝나도록 설계한다.
특히 Parus은 **“라벨 이름도 시그니처(오버로딩 키)에 포함”**되므로, named-parameter의 편의성을 넣어도 호출 해소를 흐리지 않도록 규칙을 강하게 고정한다.

---

### 6.1.1 선언 헤더(머리) 구성

함수 선언은 다음 요소들로 구성된다.

* `@attribute` : 0개 이상 (예: `@pure`, `@comptime` 등)
* `[export]` : 선택
* `def`
* `[mode]` : 선택 (`sub`, `pub` 등. class 문맥에서 의미 있음)
* `[qualifier]` : v0에서는 보류 (문서 표기는 `@pure`, `@comptime` 속성 중심)
* `Name`
* `[<TypeParams...>]` : 선택 (v1+)
* `(...)` : 파라미터 목록 (아래 6.1.2~)
* `[ConstraintClause]` : 선택 (`with [ ... ]` 단일 표기)
* `-> ReturnType`
* `Block`

**권장 고정 문법(요약)**

```ebnf
FuncDecl :=
  Attribute* ExportOpt "def" ModeOpt QualifierOpt Ident GenericParamClauseOpt FuncParams ConstraintClauseOpt "->" Type Block

ExportOpt := "export" | ε
ModeOpt   := "sub" | "pub" | ε
QualifierOpt := ε   // v0: qualifier 키워드 문법 보류, @attribute 경로만 문서화

GenericParamClauseOpt := "<" TypeParam ("," TypeParam)* ">" | ε
TypeParam := Ident
FuncParams := "(" PositionalParamsOpt NamedGroupOpt ")"
ConstraintClauseOpt := "with" "[" ConstraintList "]" | ε
```

---

### 6.1.2 파라미터 모델: “위치 파라미터” + “named group 파라미터”

Parus은 파라미터를 **두 구역**으로 나눈다.

1. **위치 파라미터(positional params)**
2. **Dart식 named parameter group `{ ... }`**

함수 선언에서 파라미터는 아래 형태를 가진다.

#### (A) 위치 파라미터(기존)

* 형태: `name: Type` 또는 `name: Type = DefaultExpr`
* 순서가 의미를 가진다.
* 호출에서는 `f(1, 2)`처럼 위치 인자로 매칭 가능.

```ebnf
PositionalParam := Ident ":" Type DefaultOpt
DefaultOpt := "=" Expr | ε
PositionalParamsOpt := (PositionalParam ("," PositionalParam)*)? 
```

#### (B) named parameter group `{ ... }` (신규, Dart 스타일)

* 형태: `{ label: Type, label2: Type = DefaultExpr, ... }`
* **이 그룹에 들어간 파라미터는 “라벨로만” 전달 가능**하다.
* 순서가 의미가 없다.
* **기본값이 있으면 생략 가능**, 기본값이 없으면 v0에서는 기본적으로 “필수”로 간주(아래 6.1.4).

```ebnf
NamedGroupOpt := (","? "{" NamedParam ("," NamedParam)* "}")? | ε
NamedParam := Ident ":" Type DefaultOpt
```

> **중요:** named-group은 선언 구역만 의미한다. 호출에서는 `{...}`를 쓰지 않고
> `f(positional..., label: expr, ...)` 형태의 tail-labeled 규칙을 사용한다(아래 6.1.5 참고).

---

### 6.1.3 함수 선언 예시 (기본형)

#### 1) 위치 파라미터만

```parus
@pure
export def add(a: int, b: int) -> int {
  return a + b;
}
```

#### 2) named group만 (전부 라벨 전달)

```parus
export def make_window({w: int, h: int, title: string = "Parus"}) -> handle<Window> {
  // ...
}
```

#### 3) 위치 + named group (권장 “실전형”)

```parus
export def spawn_entity(
  world: handle<World>,
  kind: EntityKind,
  { x: float32 = 0.0f, y: float32 = 0.0f, tag: string? = null }
) -> handle<Entity> {
  // ...
}
```

---

### 6.1.4 기본값(default) 규칙 (오버로딩과 양립하도록 고정)

기본값은 “편의 기능”이지만, 오버로딩과 섞이면 모호성이 생기기 쉬워서 **호출 해소 규칙을 먼저 고정**한다.

#### (1) 기본값의 위치

v0 권장 정책(가장 단단함):

* **named group `{}` 안에서만 기본값을 적극 권장**
* 위치 파라미터의 기본값도 허용은 가능하지만, v0에서는 아래 (3)의 “해소 우선순위”를 반드시 적용해야 한다.

#### (2) 기본값의 타입 제약(기본 원칙)

* `DefaultExpr`는 **해당 파라미터 타입에 대입 가능**해야 한다.
* `pure`/`comptime`과의 결합 세부 규칙은 v0에서 보류한다.

#### (3) 오버로딩 + 기본값: 호출 해소 우선순위(필수 규칙)

어떤 호출 `f(...)`에 대해 후보 함수가 여러 개면, 아래 순서로 고른다.

1. **(최우선) “기본값 채우기 없이” 정확히 매칭되는 후보**만 남긴다.

   * positional 인자 수/타입/순서가 정확히 맞고
   * (라벨 호출이면) 라벨 세트가 정확히 맞는 것
2. 1에서 후보가 0개라면, 그때만 **기본값 채우기를 허용**하여 매칭을 시도한다.
3. 그 결과가 정확히 1개면 선택, 2개 이상이면 **ambiguous 에러**.

이 규칙 하나로,

* “기본값 때문에 원래 존재하던 오버로드가 가려지는 문제”
* “호출이 여러 오버로드로 동시에 해석되는 문제”
  를 깔끔하게 차단할 수 있다.

---

### 6.1.5 호출 문법과 라벨 규약 (positional / labeled / named-group)

Parus 호출은 **세 가지 모드**만 허용한다.

#### (A) 위치 호출 (positional call)

* 형태: `f(Expr, Expr, ...)`
* 오직 위치 파라미터에만 매칭된다.
* named-group 파라미터는 이 방식으로 전달할 수 없다.

```parus
set x = add(1, 2);
```

#### (B) 라벨 호출 (labeled call)

* 형태: `f(a: Expr, b: Expr, ...)`
* named-only 시그니처(`def f({x: ...})`) 호출에 사용한다.
* 라벨 이름이 시그니처에 포함되므로, **라벨 이름 불일치 = 매칭 실패**다.

```parus
set y = mul(a: 1, b: 2);
```

#### (C) 위치 + 라벨 꼬리 호출 (tail labeled call, v0 고정)

* 형태: `f(Positional..., name: Expr, ...)`
* 앞부분은 positional, 뒷부분은 labeled 인자다.
* 라벨이 한 번 시작되면 이후 인자는 전부 라벨이어야 한다.
* named-group 파라미터는 호출 시 `{ ... }`를 사용하지 않는다.

```parus
set e = spawn_entity(
  world,
  EntityKind::Orc,
  x: 10.0f,
  y: 20.0f
);
```

---

### 6.1.6 named group 매칭 규칙 (필수/선택, 중복, 누락)

`def f(a: int, {x: int = 0, y: int}) -> ...` 같은 선언이 있을 때:

* named-group 파라미터 전달은 **라벨로만** 가능
* 라벨은 **중복 금지**
* 라벨은 **선언에 존재하지 않으면 에러**
* **기본값이 있는 파라미터는 생략 가능**
* **기본값이 없는 파라미터는 v0에서는 필수(생략 시 에러)**

예:

```parus
export def f(a: int, {x: int = 0, y: int}) -> int { return a + x + y; }

set ok  = f(1, y: 2);          // ok: x는 default 0
set bad = f(1, x: 3);          // error: y가 누락(필수)
set bad2 = f(1, z: 9);         // error: z는 선언되지 않음
```

---

### 6.1.7 함수 오버로딩 표준 규약 (정본, v0 고정)

이 섹션은 Parus 함수 오버로딩의 **유일한 정본 규약**이다.
문서의 다른 섹션(예: 13장)은 이 규약을 요약만 하며, 의미를 추가/변경하지 않는다.

#### (A) 오버로드 집합과 선언 경계

오버로드 집합(Overload Set)의 키:

* `bundle::(nest...)::name`
* 리시버 종류(`self` / `&self` / `&mut self` / 없음)
* 모드(`sub/pub/none`)

같은 오버로드 집합 안에서 여러 함수를 둘 수 있으나, 아래 규칙을 만족해야 한다.

#### (B) 시그니처 유일성 키(Declaration Key)

선언 충돌을 판정하는 키:

* 오버로드 집합 키
* 위치 파라미터 목록(선언 순서 고정):
  * 개수
  * 각 항목의 `label + type`
* named-group 파라미터 목록(선언 순서 고정):
  * 개수
  * 각 항목의 `label + type + required/optional(default 유무)`

제외 항목(키에 포함하지 않음):

* 반환 타입
* 기본값 표현식 본문
* `export`, `pure`, `comptime`, `commit`, `recast`

#### (C) 선언 시점 충돌 금지(사전 모호성 차단)

아래는 **호출이 없어도** 선언 시점에서 컴파일 에러로 막는다.

1. Declaration Key가 동일한 함수 2개 이상
2. 반환 타입만 다른 함수(인자 키 동일)
3. 같은 오버로드 집합에서, 위치 호출 관점으로 구분 불가능한 쌍
   (예: 위치 타입열이 동일하고 named-group이 없는 함수 2개)
4. labeled 호출 관점으로 구분 불가능한 쌍
   (라벨 집합+타입이 동일한 함수 2개)
5. 함수 1개 내부에서 파라미터 라벨 중복(위치/named-group 전체 기준)

#### (D) 호출 형태별 후보 필터

호출 `C`에 대해 후보를 모은 뒤, 먼저 호출 형태로 필터한다.

1. positional call: `f(e1, e2, ...)`
   * named-group 없는 후보만 대상
2. labeled call: `f(a: e1, b: e2, ...)`
   * named-group만 가진 후보(또는 positional 0개 + named-group) 대상
   * 라벨 집합이 후보의 named-group 라벨 집합과 일치해야 함
3. positional + labeled-tail call: `f(e1, x: e2, ...)`
   * named-group 있는 후보만 대상
   * 라벨 시작 이후 positional 인자는 금지

#### (E) 오버로딩 해소 순서(결정적)

형태 필터 후, 다음 2단계로 해소한다.

1. 단계 A: 기본값 채우기 없이 exact match 시도
2. 단계 B: 단계 A 후보가 0개일 때만 기본값 채우기 허용

판정:

* 후보 1개: 선택
* 후보 0개: not found
* 후보 2개 이상: ambiguous

추가 고정:

* 기본값은 해소 우선순위에만 영향, 오버로드 키에는 영향 없음
* 기본값 채우기로 인해 2개 이상이 살아나면 반드시 ambiguous

#### (F) 맹글링(ABI 심볼) 규약

맹글링은 위 Declaration Key를 기반으로 생성한다.

권장 포맷(v0):

```
p$<BundleId>$<Path>$<BaseName>$M<Mode>$R<Recv>$S<ParamSig>$H<Hash>
```

구성:

* `BundleId`: bundle 식별자
* `Path`: `nest` 경로(`::` -> `__`)
* `BaseName`: 함수 원이름
* `Mode`: `none|sub|pub`
* `Recv`: `none|self|ref_self|mut_self`
* `ParamSig`: 위치/ named-group 파라미터를 canonical 문자열로 직렬화
* `Hash`: canonical 문자열의 고정 해시(충돌 완화)

요구사항:

* canonical 문자열은 컴파일러 버전/플랫폼과 무관하게 안정적이어야 함
* 디버깅을 위해 `BaseName`, `Path`는 사람이 읽을 수 있어야 함

#### (G) no-mangle (`export "C"`) 제약

* `export "C"`(no-mangle export)는 오버로드 집합에 함수가 1개일 때만 허용
* 같은 C 심볼 이름으로 2개 이상 export가 가능해지는 조합은 금지
* `export "C"`는 FFI 경계 함수에만 사용한다

#### (H) 예시

```parus
def add(a: i32, b: i32) -> i32 { return a + b; }
def add(a: i32, {b: i32 = 0}) -> i32 { return a + b; }

set x = add(1, 2);         // positional -> 첫 번째
set y = add(1, b: 3);      // positional+labeled-tail -> 두 번째
set z = add(1);            // named-group default 적용 -> 두 번째
```

---


### 6.2 qualifier: pure, comptime (v0 축약)

v0에서는 `pure`와 `comptime`의 존재만 고정하고, 상세 의미/검사 규칙은 보류한다.

고정 사항:

1. 표면 표기는 `@pure`, `@comptime` 속성으로만 문서화한다.
2. 키워드형 qualifier(`def pure ...`, `def comptime ...`)는 v0 정식 문법으로 고정하지 않는다.
3. 타입체커/실행 제약(부수효과, 호출 위치, 평가 모델) 세부 규칙은 후속 문서에서 확정한다.

예시:

```parus
@pure
def clamp(p: int, lo: int, hi: int) -> int { ... }

@comptime
def pow2(n: int) -> int { ... }
```

### 6.3 호출 규칙: 위치 인자 vs 라벨 인자

* 한 호출에서 다음만 허용한다.
  * positional only
  * labeled only
  * positional prefix + labeled tail
* 라벨 시작 이후 positional 인자는 금지다.

예시

```parus
def f(a: int, b: int) -> int { return a + b; }

def calls() -> void {
  set x = f(1, 2);         // ok: positional
  set y = f(a: 1, b: 2);   // ok: labeled
  // set z = f(1, b: 2);   // error: mixed
}
```

### 6.4 `non-?` / `?` 함수, 예외 허용 범위, 호출 제약

### 6.4.1 함수 “예외 허용” 표기: 이름 접미 `?`

Parus은 함수 단위로 “예외(throw) 경로”를 **정적 분리**한다.

* **non-? 함수**: 함수 이름에 `?`가 없다.

  * `throw`, `try...catch` **전부 금지**
  * 컴파일러는 해당 함수를 **nounwind(비언와인드)**로 취급할 수 있다.
* **? 함수**: 함수 이름에 `?`가 붙는다.

  * `throw`, `try...catch` **허용**
  * 호출 그래프 상 예외 전파 경로가 존재할 수 있다.

문법 예시:

```parus
def parse_u32(text: string) -> Result<u32> { ... }     // non-?
def read_file?(path: string) -> bytes { ... }          // ?
```

> `?`는 반환 타입(nullable)과 무관하며, **오직 예외 메커니즘(throw/catch) 허용 여부**만 뜻한다.

---

### 6.4.2 non-? 함수에서의 금지 규칙(강제)

non-? 함수 본문에서는 아래가 **컴파일 에러**다.

* `throw ...;`
* `try { ... } catch (...) { ... }`
* `try` / `catch` 키워드가 포함된 모든 문장/구문
* **? 함수 호출** (단, 아래 6.X.4 “예외=>Result 브리지”를 통해서만 예외를 값으로 받는 것은 허용)

예시:

```parus
def bad() -> void {
  throw Err("nope");          // error
}

def also_bad() -> void {
  try { ... } catch (e) { }   // error
}
```

---

### 6.4.3 ? 함수에서의 허용 규칙(기본)

? 함수는 `throw`, `try...catch`를 사용할 수 있으며, **잡히지 않은 예외는 자동 전파**된다.

```parus
def open_config?(path: string) -> Config {
  set bytes = read_file?(path: path);   // 여기서 throw되면 자동 전파
  return parse_config?(bytes: bytes);   // 자동 전파
}
```

---

### 6.4.4 예외 => `Result<T>` 브리지: `attempt` (추가, non-?에서도 사용 가능)

non-? 함수는 예외를 직접 다룰 수 없으므로, **예외를 값(`Result<T>`)으로 포획**하는 브리지를 제공한다.

* `attempt Expr;` 는 **Expr 실행 중 발생한 throw를 잡아** `Result<T>`로 만든다.
* Expr은 보통 `? 함수 호출`이 된다.
* `attempt` 자체는 **try...catch 문법이 아니다**. (non-?에서 허용)

형태:

```parus
let r: Result<T> = attempt some_throwing_call?(...);
```

예시:

```parus
def load_config(path: string) -> Result<Config> {
  set bytes_r = attempt read_file?(path: path);   // Result<bytes>
  switch (bytes_r) {
    case Ok(bytes): {
      // parse는 non-? Result 기반 API를 사용한다고 가정
      return parse_config(bytes: bytes);
    }
    case Err(e): {
      return Err(e);
    }
  }
}
```

`attempt`는 컴파일러가 제공하는 최소 런타임(EH 포획 경계)로 lowering 되며,
**-fno-std 모드에서는 금지**(3.X 참조)로 두는 것을 v0 정책으로 한다.


---
