## 10.4 Generics + Proto/Class/Acts (v1)

문서 상태: `Normative`

### 함수 제약 규칙

1. 함수 제약절은 `with [T: ProtoName, ...]` 형태를 사용한다.
2. `with` 절은 함수 파라미터 뒤, 반환 타입 `->` 앞에 위치한다.
3. 제약은 함수 제네릭 파라미터에만 걸 수 있다.
4. 존재하지 않는 타입 파라미터에 제약을 걸면 오류다.
5. 제약 경로가 proto 선언으로 해석되지 않으면 오류다.

예시:

```parus
proto Equatable {
  def eq(self, rhs: &Self) -> bool;
} with require(true);

def same<T>(a: &T, b: &T) with [T: Equatable] -> bool {
  return true;
}
```

### 선언 레벨 제네릭 (class/proto/acts)

1. `class`, `proto` 선언은 제네릭 파라미터를 가질 수 있다.
2. `class`/`struct` 제약절은 `with [T: Proto]` 문법을 사용한다.
3. `class A : Proto<i32>` 같은 제네릭 proto 적용 경로를 허용한다.
4. `acts` 제네릭은 owner 타입 표기만 허용한다:
5. 허용: `acts for Vec<T> with [T: Proto] { ... }`
6. 금지: `acts for Vec<T> <T> { ... }`

예시:

```parus
proto Holder<T> {
  def get(self) -> T;
};

class IntHolder: Holder<i32> {
  init() = default;
  def get(self) -> i32 { return 1i32; }
}

class Vec<T> {
  data: T;
  init(v: T) { self.data = v; }
}

acts for Vec<T> {
  def get(self) -> T {
    return self.data;
  }
}
```

### 컴파일타임 고정 규칙

1. 제네릭 해소는 정적 모노모피제이션으로만 수행한다.
2. 템플릿 선언 자체는 하향 대상이 아니다.
3. concrete 인스턴스만 SIR/OIR/LLVM으로 내려간다.
4. `dyn` 경계/런타임 디스패치는 본 장의 범위 밖이다.

### 주요 진단 코드

1. `GenericArityMismatch`
2. `GenericTypeArgInferenceFailed`
3. `GenericAmbiguousOverload`
4. `GenericConstraintProtoNotFound`
5. `GenericConstraintUnsatisfied`
6. `GenericUnknownTypeParamInConstraint`
7. `GenericDeclConstraintUnsatisfied`
8. `GenericTypePathArityMismatch`
9. `GenericTypePathTemplateNotFound`
10. `GenericActsOverlap`
11. `ActsGenericClauseRemoved`
12. `GenericFieldNotSupportedV1`
13. `GenericActorDeclNotSupportedV1`

### 비지원 (v1)

1. 브래킷 없는 `with T: P` 문법
2. proto 외 타깃 제약
3. 매크로/메타 프레디킷 기반 제약식
4. generic `struct` 전면 지원
5. generic `actor` 전면 지원
6. `dyn` 결합/런타임 모노모피제이션
