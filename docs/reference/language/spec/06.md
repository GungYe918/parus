## 4. 타입 시스템 (v0 정의 + 향후 확장 방향)

### 4.1 원시 타입 (fixed-width)

* 정수: int8 int16 int32 int64, uint8 uint16 uint32 uint64
* 부동: float32 float64
* bool, char, text
* 별칭(구현 선택): int = int32, float = float32

예시

```parus
def primitives() -> void{
  let a: int32 = 1i32;
  let b: uint64 = 2u64;
  let c: bool = true;
  let d: char = 'Z';
  let s: text = "hi";
}
```

### 4.2 nullable 타입 (T?)

* nullable은 `T?`로 표기한다.
* `T?`는 `T` 값 또는 `null`을 담는 1급 값 타입이다.
* non-nullable `T`에 `null`을 대입/반환/전달하면 에러다.
* `if (x == null)` 비교는 nullable 문맥에서만 허용한다.
* 하이브리드 승격 규칙:
  * 대입 경계에서는 `T -> T?` 암시 주입 허용
  * 표현식 전역 승격(`T <: T? everywhere`)은 금지
* nullable 관련 정본은 `docs/reference/abi/v0.0.1/NULLABLE_MODEL.md`를 따른다.

예시

```parus
def nullable_demo() -> void {
  let a: int? = null;
  let b: int? = 3i32;

  if (a == null) {
    // ...
  }
}
```

### 4.3 배열과 리스트

* 고정 배열: T[N]
* 가변 리스트: T[]

예시

```parus
def arrays_lists() -> void {
  let xs: int[3] = [1, 2, 3];
  // let ys: int[] = [1, 2, 3]; // 리스트 리터럴 문법은 v0에서 선택 구현
}
```

### 4.4 타입 시스템 작동 원리 (v0 -> 향후)

> 제네릭/제약 표기의 합의 정본은 `docs/reference/abi/v0.0.1/GENERICS_MODEL.md`다.

v0에서 타입 시스템은 다음 순서로 작동하는 것을 목표로 한다.

1. 파서가 AST를 만든다.
2. 타입체커가 심볼 테이블을 만들고, 선언을 수집한다.
3. 타입체커가 표현식을 하향식/상향식으로 검사하며 타입을 확정한다.
4. 연산자, 호출, 변환 규칙을 적용한다.
5. 오류는 Span 기반 진단으로 보고한다.

향후 확장 (v1+ 로드맵 성격, v0에 포함되는 개념만 선명히):

* 제네릭 타입: `TypeName<T>` 형태
* 제네릭 함수: `def foo<T>(...) with [ ... ] -> R { ... }`
* 제약 선언은 `with [ ... ]` 단일 표기로 사용
* `with T: P`(브래킷 없는 with) / `[]` 단독 제약 표기는 금지
* 제약이 1개여도 `with [T: P]`처럼 브래킷을 유지
* 제네릭 실체화 전략은 기본적으로 monomorphization(컴파일 시 실체화)을 우선
* `proto`가 제네릭 capability 제약의 중심 역할을 맡는다
* 타입 추론 강화: set 바인딩의 추론, 간단한 반환 타입 추론 (v0에서는 강제 유지)

예시 (향후 제네릭 목표 형태, v0에서는 파싱/문서 선행 가능):

```parus
// v1+ 목표 예시 (권장)
// def contains<T>(xs: &[T], x: &T) with [T: Hashable, T: Equatable] -> bool { ... }
```

### 4.5 storage class 키워드: `static`

Parus v0에서는 “값이 어디에 저장되고(저장소/수명), 소유권이 어떻게 제한되는지(유일성)”를 명시적으로 표현하기 위해 `static`을 제공한다.

* `static` : **정적 저장소(static storage)** 를 의미한다. 스코프를 벗어나도 저장이 유지되며(프로그램 수명), 해당 place의 주소/저장 위치는 컴파일 타임에 고정된다.

#### (1) 문법(권장)

`static`은 변수/전역/필드 선언에 붙는 **storage class**로 취급한다.

```parus
static G: i32 = 3i32;
static mut UART0: Uart? = null;
```

권장 순서(가독성 규칙):

```
static mut Name: T = Init;
```

*의미론상 순서는 중요하지 않으나, v0 문서/스타일은 위 순서를 권장한다.*

#### (2) `static`의 의미(저장 기간/초기화)

v0 권장(= freestanding 친화) 규칙:

* `static` 선언은 **반드시 초기화 값을 가져야 한다.**
* `static` 초기화와 `comptime` 결합 규칙은 v0에서 상세를 보류한다.
  * 현재는 구현/도구체인 상황에 따라 보수적으로 제한할 수 있다.

이 규칙은 다음을 보장한다.

* `no-std` / freestanding 환경에서 런타임 초기화 의존을 만들지 않는다.
* 초기화 순서/재진입 문제를 최소화한다.

#### (3) `T?`(nullable)와 `static/unique`의 결합 패턴(v0 권장)

freestanding에서 “나중에 초기화”가 필요한 전역 자원은 다음 패턴을 권장한다.

```parus
static mut LOGGER: Logger? = null;

def init_logger() -> void {
  LOGGER = Logger::init(); // 런타임 초기화(명시적)
}
```

* `static` 초기값으로는 `null`을 사용(상수 초기화).
* 이후 초기화는 명시적 init 단계에서 수행.

#### (5) 주의(동시성/재진입)

`static mut`는 데이터 레이스/재진입 문제가 생길 수 있다. v0에서는 동시성 모델을 최소화할 수 있으므로, 구현/프로젝트 정책으로 다음 중 하나를 택해 고정하는 것을 권장한다.

* 단일 스레드/단일 코어 가정(예: bare-metal 초기 단계)
* `critical` 같은 구문/프리미티브 내부에서만 `static mut` 접근 허용(미래 확장)

이 규칙은 `static` 자체의 의미와는 별개이며, 접근 안전성 정책이다.

---

