## 2. 리터럴

### 2.1 정수 리터럴

* 예: 123, 1_000_000
* 숫자 구분자 _ 는 숫자 그룹 사이에만 허용한다. (선두/말미/연속 금지)
* 접미사: i8 i16 i32 i64 u8 u16 u32 u64 (및 단축 u, i는 금지 권장. v0에서는 명확함을 우선)

예시

```parus
def int_literals() -> void {
  let a: u32 = 123u32;
  let b: u64 = 1_000_000u64;
}
```

### 2.2 실수 리터럴

* 접미사 필수:

  * f: float32
  * lf: float64

예시

```parus
def float_literals() -> void {
  let x: float32 = 3.14f;
  let y: float64 = 2.71828lf;
}
```

### 2.3 불리언, null

* true, false
* null은 값 부재를 나타내는 리터럴이다.
* `T <: T?` 전역 승격은 허용하지 않는다.
* 단, 대입 경계(let/set 초기화, `=`, field init, call arg, return, default arg, `??=`)에서는
  `T -> T?` 암시 주입을 허용한다.

예시

```parus
def bool_null() -> void {
  let t: bool = true;
  let f: bool = false;
  // let x: int = null; // error
}
```

### 2.4 문자 리터럴 (char)

* 형태: 'a', '\n', '\t', '\', ''', '"'
* 유니코드 코드포인트 표기(권장): '\u{AC00}' 같은 형태를 지원한다.

예시

```parus
def char_literals() -> void {
  let c1: char = 'a';
  let c2: char = '\n';
  let c3: char = '\u{AC00}';
}
```

### 2.5 문자열 리터럴

* 기본 문자열: `"..."` (v0 활성)
* 기본 문자열 리터럴의 타입은 항상 `text`다.
* Raw/F-string 문법은 v0에서 예약 상태다.
* `R"""..."""`, `F"""..."""`는 lexer/parser에서 문자열 리터럴로 활성화한다.
* `F"""..."""`의 `{expr}` 보간 lowering은 v0에서 미구현이며, 현재는 본문 텍스트를 그대로 `text`로 취급한다.
* 표준 라이브러리 `String`이 링크되어도 `""` 기본 타입은 바뀌지 않는다.
* `text -> String` 암시 변환은 금지한다(명시 API 변환만 허용).

예시

```parus
def strings() -> void {
  let raw_name: text = "parus";
  // let owned: String = String::from_text(src: raw_name); // std 링크 후 명시 변환
}
```

---

