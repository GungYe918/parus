## 16. EBNF 테이블 (v0 전체 문서 반영, 파서 제작 가능 수준)

> 표기 규칙
> `ε` = empty, `?` = optional, `*` = 0+ 반복, `+` = 1+ 반복
> `A | B` = 선택, `( ... )` = 그룹, `'tok'` = 리터럴 토큰
> **세미콜론 `;`은 “문장 종결자”**이며, `Block`은 종결자 없이 문장으로 취급된다.

---

### 16.1 Lexical (토큰 레벨)

```ebnf
Letter        := /* Unicode XID_Start (권장) 또는 구현상 IDENT_START */
LetterCont    := /* Unicode XID_Continue (권장) 또는 구현상 IDENT_CONT */

Ident         := Letter LetterCont* | BacktickIdent ;
BacktickIdent := "`" /* UTF-8 any (incl emoji) except ` and newline */ "`" ;

IntLit        := Digit (Digit | "_")* IntSuffix? ;
IntSuffix     := "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64" ;

FloatLit      := Digit (Digit | "_" | ".")* FloatSuffix ;
FloatSuffix   := "f" | "lf" ;

BoolLit       := "true" | "false" ;
NullLit       := "null" ;

CharLit       := "'" CharBody "'" ;
CharBody      := /* 'a' | escape sequences | '\u{HEX+}' etc. */ ;

StringLit     := NormalString | FString | RawString ;
NormalString  := "\"" /* ... */ "\"" ;
FString       := "F\"\"\"" /* ... { Expr } ... */ "\"\"\"" ;
RawString     := "R\"\"\"" /* ... no interpolation ... */ "\"\"\"" ;

Comment       := LineComment | BlockComment ;
LineComment   := "//" /* to end of line */ ;
BlockComment  := "/*" /* ... */ "*/" ;   /* non-nested */

WS            := /* spaces/tabs/newlines */ ;
```

---

### 16.2 프로그램 구조: project/bundle/module/file 단위

```ebnf
File          := (Item | EmptyItem)* EOF ;

EmptyItem     := ";" ;

Item          := DeclItem
               | DirectiveItem ;

DeclItem      := BracedDeclItem
               | SimpleDeclItem ;

BracedDeclItem:= NormalFuncDecl
               | CAbiFuncDef
               | FieldDecl
               | ProtoDecl
               | ClassValueDecl
               | ActsDecl
               | ClassDecl ;

SimpleDeclItem:= CAbiFuncDecl
               | GlobalVarDecl ;

DirectiveItem := ImportStmt
               | UseStmt
               | NamespaceDecl ;
```

---

### 16.3 경로 / 네임스페이스(nest)

```ebnf
Path          := Ident ("::" Ident)* ;

NamespaceDecl := ExportOpt "nest" Path ( ";" | BlockNamespace ) ;
BlockNamespace:= "{" NamespaceItem* "}" ;

NamespaceItem := UseStmt
               | NamespaceDecl
               | Decl
               | ";" ;
```

### 16.4 `import`/`use` 문

```ebnf
ImportStmt    := "import" Path ("as" Ident)? ";" ;

UseStmt       := "use" UseBody ";" ;

UseBody       := UseTypeAlias
               | UsePathAlias
               | UseNestAlias
               | UseTextSubst
               | UseActsSelect
               ;

UseTypeAlias  := Ident "=" Type ;
UsePathAlias  := Path ("=" | "as") Ident ;     /* 경로 별칭 */
UseNestAlias  := "nest" Path ("as" Ident)? ;   /* namespace 별칭(= 금지) */
UseTextSubst  := Ident Expr ;                  /* IDENT 단위 치환(매크로 함수 금지) */
UseActsSelect := ActsTargetType "with" "acts" "(" ActsSetName ")" ;
ActsTargetType:= PathType ;
ActsSetName   := Ident | "default" ;
```

---

### 16.5 선언(Decl) 전체

```ebnf
Decl          := FuncDecl
               | FieldDecl
               | ProtoDecl
               | ClassValueDecl
               | ActsDecl
               | ClassDecl
               | GlobalVarDecl
               ;

ExportOpt     := "export" | ε ;

Attribute     := "@" Ident
               | "@{" AttrItem ("," AttrItem)* "}" ;
AttrItem      := Ident (":" AttrValue)? ;
AttrValue     := Ident | IntLit | FloatLit | StringLit | BoolLit | NullLit ;

AccessMod     := "public" ":" | "private" ":" ;
```

---

### 16.6 전역/정적 변수 선언

```ebnf
GlobalVarDecl    := CAbiGlobalDecl | NormalGlobalDecl ;

CAbiGlobalDecl   := LinkPrefix "static" MutOpt Ident ":" Type CAbiInitOpt ";" ;
LinkPrefix       := ("extern" | "export") "\"C\"" ;
CAbiInitOpt      := "=" Expr | ε ;              /* extern 경로에서는 ε */

NormalGlobalDecl := StorageOpt MutOpt VarKw IdentVarDecl ";" ;
StorageOpt       := "static" | ε ;
MutOpt           := "mut" | ε ;
VarKw            := "let" | "set" ;

IdentVarDecl     := LetDecl | SetDecl ;
LetDecl          := Ident ":" Type "=" Expr ;
SetDecl          := Ident "=" Expr ;
```

---

### 16.7 함수 선언 (attribute/export/mode/qualifier/제네릭/제약/예외접미 `?`)

```ebnf
FuncDecl      := CAbiFuncDecl | CAbiFuncDef | NormalFuncDecl ;

CAbiFuncDecl  := "extern" "\"C\"" "def" FuncName FuncParams "->" Type ";" ;
CAbiFuncDef   := "export" "\"C\"" "def" FuncName FuncParams "->" Type Block ;
NormalFuncDecl:= Attribute* ExportOpt "def" ModeOpt QualifierOpt FuncName GenericParamClauseOpt FuncParams ConstraintClauseOpt "->" Type Block ;

FuncName      := Ident QMarkOpt ;
QMarkOpt      := "?" | ε ;                     /* 예외 허용 함수 표기 */

ModeOpt       := "sub" | "pub" | ε ;           /* actor 문맥에서 의미 있음 */
QualifierOpt  := ε ;                             /* v0: qualifier 키워드 문법은 보류, @attribute 경로만 문서화 */

GenericParamClauseOpt := "<" TypeParam ("," TypeParam)* ">" | ε ;
TypeParam     := Ident ;

FuncParams    := "(" ParamSectionOpt ")" ;

ParamSectionOpt :=
                 ε
               | PositionalParamsOpt NamedGroupOpt
               ;

PositionalParamsOpt :=
                 PosParam ("," PosParam)* ("," )?
               | ε ;

PosParam      := Ident ":" Type DefaultOpt ;

NamedGroupOpt := "{" NamedParamListOpt "}" | ε ;
NamedParamListOpt :=
                 NamedParam ("," NamedParam)* ("," )?
               | ε ;

NamedParam    := Ident ":" Type DefaultOpt ;

DefaultOpt    := "=" Expr | ε ;

ConstraintClauseOpt := WithBracketConstraintClause
                     | ε ;

WithBracketConstraintClause := "with" "[" ConstraintList "]" ;
ConstraintList := Constraint ("," Constraint)* ;
Constraint    := Ident ":" PathType ;
```

---

### 16.8 타입(Type) 문법 (nullable, 배열/리스트, borrow/slice, handle, 제네릭(파싱 선행))

```ebnf
Type          := TypePrimary TypeSuffix* ;

TypePrimary   := "(" Type ")" 
               | "handle" "<" Type ">"
               | SliceType
               | PathType
               | ArrayOrListType
               ;

PathType      := Path GenericArgsOpt ;
GenericArgsOpt:= "<" Type ("," Type)* ">" | ε ;

ArrayOrListType :=
                 PathType "[" ArrayLenOpt "]"
               | "(" Type ")" "[" ArrayLenOpt "]" ;      /* 괄호 타입도 지원 */

ArrayLenOpt   := Expr | ε ;                 /* empty => list T[] */
               /* T[N] : ArrayLenOpt=Expr, T[] : ArrayLenOpt=ε */

SliceType     := RefPrefix "[" Type "]" ;   /* &[T], &mut [T] */

RefPrefix     := "&" MutOpt ;               /* &, &mut */

TypeSuffix    := "?" ;                      /* nullable: T? (접미가 &보다 우선 결합 권장) */
```

> **주의(우선순위 정책 반영)**: `&i32?`는 문법적으로 `RefPrefix`가 `TypePrimary`의 한 형태가 아니라, `SliceType` 외에는 `&`가 “표현식 연산자”에 가까워 충돌 소지가 있으므로, 타입에서 `&T` 자체를 원한다면 아래 “RefType” 확정을 선택해도 된다. (아래 16.15 모호점 참고)

---

### 16.9 field / proto / class / acts

```ebnf
FieldDecl     := "field" FieldLayoutOpt FieldAlignOpt Ident BlockField ;
FieldLayoutOpt:= "layout" "(" "c" ")" | ε ;
FieldAlignOpt := "align" "(" IntLit ")" | ε ;
BlockField    := "{" FieldMember* "}" ;
FieldMember   := Ident ":" Type ";" ;       /* field 내부 함수 금지 */

ProtoDecl     := ExportOpt "proto" Ident ProtoInheritOpt BlockProto ProtoRequireTailOpt ";" ;
ProtoInheritOpt := ":" PathType ("," PathType)* | ε ;
BlockProto    := "{" ProtoMember* "}" ;
ProtoMember   := ProtoMethodSig ( ";" | Block ";"? ) ;
ProtoMethodSig:= "def" Ident QMarkOpt GenericParamClauseOpt FuncParams ConstraintClauseOpt "->" Type ;
ProtoRequireTailOpt := "with" "require" "(" Expr ")" | ε ;

ClassValueDecl:= ExportOpt "class" Ident InheritOpt BlockClassValue ;
InheritOpt    := ":" PathType ("," PathType)* | ε ;

BlockClassValue := "{" ClassValueMember* "}" ;
ClassValueMember := AccessMod
               | ClassLifecycleMember
               | FuncDecl
               | MemberVarDecl
               | ";" ;

MemberVarDecl := MutOpt ("let" | "set") IdentVarDecl ";" ;

ClassLifecycleMember := InitDecl | DeinitDecl ;
InitDecl        := "init" FuncParams ClassLifecycleBody ;
DeinitDecl      := "deinit" "(" ")" ClassLifecycleBody ;
ClassLifecycleBody := Block ";"?
                    | "=" "default" ";" ;

ActsDecl      := ExportOpt "acts" ActsHead BlockActs ;
ActsHead      := "for" Type
               | Ident
               | Ident "for" Type ;
BlockActs     := "{" ActsMember* "}" ;
ActsMember    := FuncDecl
               | OperatorDecl
               | ";" ;

OperatorDecl  := "operator" "(" OperatorName ")" FuncParams "->" Type Block ;
OperatorName  := PunctOp | "++pre" | "++post" ;

PunctOp       := "+" | "-" | "*" | "/" | "%" | "==" | "!=" | "<" | "<=" | ">" | ">="
               | "[]" | "()" | "++" | "=" | "+=" | "-=" | "*=" | "/=" | "%="
               | "and" | "or" | "xor" | "not" ;
```

---

### 16.10 actor + draft/pub/sub + commit/recast (구문 레벨)

```ebnf
ClassDecl     := ExportOpt "actor" Ident BlockClass ;

BlockClass    := "{" ClassMember* "}" ;

ClassMember   := AccessMod
               | FuncDecl
               | MemberVarDecl
               | ";" ;
```

---

### 16.11 문장(Statement) / 블록 / 바인딩

```ebnf
Block         := "{" Stmt* "}" ;

Stmt          := ";"
               | Block
               | UseStmt
               | VarStmt
               | IfExprStmt
               | WhileStmt
               | LoopStmt
               | SwitchStmt
               | BreakStmt
               | ContinueStmt
               | ReturnStmt
               | ThrowStmt
               | TryCatchStmt
               | AttemptStmt
               | CommitStmt
               | RefreshStmt
               | RecastStmt
               | DeleteStmt
               | ExprStmt
               ;

VarStmt       := StorageOpt MutOpt VarKw IdentVarDecl ";" ;

ExprStmt      := Expr ";" ;
```

---

### 16.12 if / while / loop / switch

```ebnf
IfExprStmt    := IfExpr ";"? ;          /* if는 표현식이지만, stmt로도 사용 가능 */

IfExpr        := "if" "(" Expr ")" Block ElifPart* ElsePartOpt ;
ElifPart      := "elif" "(" Expr ")" Block ;
ElsePartOpt   := "else" Block | ε ;

WhileStmt     := "while" "(" Expr ")" Block ;

LoopStmt      := "loop" LoopBody ;
LoopBody      := Block
               | "(" Ident "in" Expr ")" Block ;

SwitchStmt    := "switch" "(" Expr ")" "{" SwitchCase* DefaultCaseOpt "}" ;
SwitchCase    := "case" CaseLabel ":" Block ;
DefaultCaseOpt:= "default" ":" Block | ε ;

CaseLabel     := Literal
               | Pattern ;

Pattern       := Ident "(" PatternArgsOpt ")" ;
PatternArgsOpt:= Ident
               | Ident ":" Ident
               | ε ;
```

---

### 16.13 break/continue/return/throw/try-catch/attempt/commit/delete/recast

```ebnf
BreakStmt     := "break" BreakValueOpt ";" ;
BreakValueOpt := Expr | ε ;

ContinueStmt  := "continue" ";" ;

ReturnStmt    := "return" ReturnValueOpt ";" ;
ReturnValueOpt:= Expr | ε ;

ThrowStmt     := "throw" Expr ";" ;

TryCatchStmt  := "try" Block "catch" "(" CatchBinder ")" Block ;
CatchBinder   := Ident (":" Type)? ;    /* 예: catch(e: Error) */

AttemptStmt   := "attempt" Expr ";" ;   /* 또는 "set r = attempt expr;"를 Expr로 취급할 수도 있음 */

CommitStmt    := "commit" ";" ;
RecastStmt    := "recast" RecastArgOpt ";" ;
RecastArgOpt  := Expr | ε ;

DeleteStmt    := "delete" PlaceExpr ";" ;
```

---

### 16.14 표현식(Expression) (우선순위/결합 규칙 포함)

> 아래는 **프랫/우선순위 파서 제작 가능한 형태**로 계층을 분리했다.
> (v0 규칙: 삼항 `?:` 중첩 금지, `<<` 파이프는 RHS가 CallExpr이며 hole `_` 1개 강제)

```ebnf
Expr          := AssignExpr ;

AssignExpr    := TernaryExpr (AssignOp AssignExpr)? ;
AssignOp      := "=" | "+=" | "-=" | "*=" | "/=" | "%=" ;

TernaryExpr   := PipeExpr ("?" PipeExpr ":" PipeExpr)? ; /* v0: nested ternary 금지(검사로 제약) */

PipeExpr      := OrExpr ( "<<" PipeRhs )* ;
PipeRhs       := CallExpr ;  /* v0 강제: RHS는 CallExpr */

OrExpr        := XorExpr ( "or" XorExpr )* ;
XorExpr       := AndExpr ( "xor" AndExpr )* ;
AndExpr       := EqExpr  ( "and" EqExpr )* ;

EqExpr        := RelExpr ( ("==" | "!=") RelExpr )* ;
RelExpr       := AddExpr ( ("<" | "<=" | ">" | ">=") AddExpr )* ;

AddExpr       := MulExpr ( ("+" | "-") MulExpr )* ;
MulExpr       := PrefixExpr ( ("*" | "/" | "%") PrefixExpr )* ;

PrefixExpr    := PrefixOp PrefixExpr
               | PostfixExpr ;

PrefixOp      := "not" | "!" | "+" | "-" | "++"
               | BorrowOp
               | EscapeOp
               ;

BorrowOp      := "&" MutOpt ;            /* &x, &mut x */
EscapeOp      := "&&" ;                  /* &&x */

PostfixExpr   := PrimaryExpr PostfixOp* ;
PostfixOp     := CallSuffix
               | IndexSuffix
               | MemberSuffix
               | PostIncSuffix ;

CallSuffix    := "(" ArgListOpt ")" ;
IndexSuffix   := "[" Expr "]" ;
MemberSuffix  := "." Ident ;
PostIncSuffix := "++" ;

PrimaryExpr   := Literal
               | IdentRef
               | Hole
               | ParenExpr
               | ArrayLiteral
               | LambdaExpr
               ;

ParenExpr     := "(" Expr ")" ;

IdentRef      := Path ;                  /* 변수/함수/네임스페이스/타입 경로 */
Hole          := "_" ;                    /* 파이프/호출 규칙에서 “라벨 인자 자리”로만 허용(검사 패스) */

Literal       := IntLit | FloatLit | BoolLit | NullLit | CharLit | StringLit ;

ArrayLiteral  := "[" ExprListOpt "]" ;
ExprListOpt   := (Expr ("," Expr)*)? ("," )? ;

ArgListOpt    := ArgList | ε ;
ArgList       := PosArgsOpt NamedArgsOpt ;    /* 혼합 규칙은 아래에서 제약 */

PosArgsOpt    := (Expr ("," Expr)*)? ("," )? | ε ;

NamedArgsOpt  := NamedGroupArgs | LabeledArgs | ε ;

LabeledArgs   := LabelArg ("," LabelArg)* ("," )? ;
LabelArg      := Ident ":" ExprOrHole ;
ExprOrHole    := Expr | "_" ;

NamedGroupArgs:= ("," )? "{" NamedGroupArgListOpt "}" ;
NamedGroupArgListOpt := (NamedGroupArg ("," NamedGroupArg)*)? ("," )? ;
NamedGroupArg := Ident ":" Expr ;

LambdaExpr    := CaptureList LambdaParamsOpt LambdaRetOpt Block ;
CaptureList   := "[" CaptureItemsOpt "]" ;
CaptureItemsOpt := (CaptureItem ("," CaptureItem)*)? ("," )? ;
CaptureItem   := MutOpt Ident ;

LambdaParamsOpt := "(" ParamSectionOpt ")" ;     /* v0: 예시가 [](x:int){...} 형태 */
LambdaRetOpt  := ("->" Type)? ;
```

호출 해석 규칙(v0):

1. `A(...)`에서 `A`가 class 타입 경로면 생성식으로 해석하며 `A::init(...)` 오버로드를 대상으로 매칭한다.
2. `a.m(...)` dot 호출은 첫 파라미터가 `self`인 메서드 후보만 허용한다.
3. `A::m(...)`/`Proto::m(...)`의 class/proto 멤버 경로 호출은 제거한다.
4. `T::acts(Name)::member(...)` 및 일반 namespace 경로 호출은 유지한다.

---

### 16.15 Place Expression (place 제약: `&`, `&&`, delete 대상)

```ebnf
PlaceExpr     := PlaceAtom PlaceSuffix* ;

PlaceAtom     := IdentRef | "(" PlaceExpr ")" ;

PlaceSuffix   := "." Ident
               | "[" Expr "]" ;
```

---
