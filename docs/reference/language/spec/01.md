## 0. 설계 목표와 철학

### 0.1 핵심 목표

* SMP + SIMD 친화: 병렬 처리와 벡터화에 유리한 데이터/제어 구조를 제공한다.
* 명시적 코드 플로우: 암묵 복사, 암묵 삽입, 암묵 실행을 최소화해 비용과 흐름이 코드에서 드러나게 한다.
* 대단위 상태 공유 생산성: Rust의 단일 소유권이 유발하는 빌림/복사 폭증을 완화한다.
* 순환참조 문제 실질적 제거: 포인터 기반 객체 그래프 대신 Handle+Store, ECS 패턴을 강권한다.
* 기본적으로 모든 연산은 move기반이며, 복사 시 명시적으로 copy/clone을 요구한다.

예시 (철학이 반영된 스타일, 작은 데이터는 값, 큰 상태는 actor)

```parus
@pure
export def demo_small_big() -> void {
  set x = 3;
  set y = x + 2;

  // 큰 상태는 actor draft + pub/sub + commit으로 관리되는 방향을 지향
}
```

### 0.2 작은 데이터 vs 큰 상태 (이원 모델)

* 작은 데이터 전달/공유: 기본은 move, 필요 시 copy를 명시한다. (borrow/ref는 v0에서 설계 포함, 구현은 단계적으로)
* 큰 공유 컨텍스트: actor draft + pub/sub + commit 모델을 사용한다.

  * sub: draft 스냅샷 읽기 전용
  * pub: draft 수정 + commit 강제

예시

```parus
actor Counter {
  draft {
    count: i32;
  }

  init(seed: i32) {
    draft.count = seed;
  }

  def sub get() -> i32 {
    recast;
    return draft.count;
  }

  def pub inc() -> i32 {
    draft.count = draft.count + 1i32;
    commit;
    return draft.count;
  }
}
```

### 0.3 타입 정의 모델: field, proto, class, acts

* field: POD 저장소. 생성자/소멸자 없음. 함수 포함 금지.
* proto: 인터페이스(계약). 생성자/소멸자 없음.
* class: 구현체 타입. `init/deinit` lifecycle을 가지며, 필드는 `x: T;` 형태만 허용한다.
* class 상속은 금지한다. 다형성은 `proto` 제약으로 구성한다.
* acts: 특정 타입에 대한 행동(함수, 연산자)을 정의하는 블록. field 내부 함수 금지 대신 acts로 유도.

예시 (개념 맛보기)

```parus
export field Vec2 {
  x: i32;
  y: i32;
}

proto Drawable {
  def draw(self) -> i32;
}

class Sprite : Drawable {
    pos: Vec2;
    init() = default;

    def draw(self) -> i32 {
      return 0i32;
    }
}
```

---
