## 3. 프리패스와 단위 계층, `import`/`use`, FFI

참고:

1. 본 장의 bundle/module 해석 규칙 정본은 `docs/reference/language/spec/30_BUNDLE_MODULE_RESOLUTION.md`를 따른다.

### 3.1 단위 용어: file / module / bundle / project

Parus 빌드는 다음 4단위를 가진다.

* **file**: 하나의 소스 파일(`*.pr`). 파싱 단위.
* **module**: `config.lei` 루트 기준 논리 경로 head 단위.
* **bundle**: 컴파일/배포 단위. LEI의 `bundle` plan으로 정의.
* **project**: 여러 bundle을 묶는 최상위 단위(workspace).

권장 계층:

```text
file -> module -> bundle -> project
```

핵심 원칙:

* Parus는 **bundle 단위 선언 수집 prepass**를 수행한다.
* prepass 대상 심볼은 `def/var/field/acts` 전체다.
* 선언 순서는 의미를 갖지 않는다(전방참조 허용).
* 공개 범위는 `export`로만 결정된다.

### 3.1.1 bundle prepass와 심볼 수집

bundle prepass는 다음 인덱스를 분리해 유지한다.

* **export 면**: cross-file/cross-bundle 참조 가능 후보
* **internal 면**: 선언 파일 내부에서만 참조 가능 후보

규칙:

* 동일 파일 내부 참조는 기존처럼 자유.
* 같은 bundle에서도 다른 파일 참조는 공개 정책을 따른다.
* 같은 폴더에서는 `export` 선언만 자동 가시화된다.
* `export` 없는 선언은 파일 내부 전용이다.

### 3.1.2 모듈 head 정본

`import <head>`의 `<head>`는 `config.lei` 루트 기준 논리 경로(`::`)를 사용한다.

예시:

* `/foo/app/src/main.pr` -> head `app`
* `/foo/app/src/net/http.pr` -> head `app::net`

추가 규칙:

* head 해석은 파일명보다 폴더 경로를 우선한다.
* 같은 폴더 파일들은 동일 head에 속한다.
* `nest`는 head 계산에 영향을 주지 않는다.

### 3.1.3 `import` 문 (alias 도입, include 금지)

문법:

```parus
import math;
import math as m;
import app::net as anet;
```

규칙(v0 고정):

* `import`는 **include가 아니다**.
* 현재 파일 스코프에 alias 심볼 1개만 도입한다.
* alias 생략 시 마지막 경로 세그먼트를 alias로 사용한다.
* 외부 심볼은 자동 평탄화되지 않는다. 항상 `alias::...`로 접근한다.
* `import <head>`의 `<head>`는 현재 module `imports`에 반드시 선언되어야 한다.
* cross-bundle 참조가 발생하면 대상 bundle이 현재 bundle `deps`에도 선언되어야 한다.
* `import`는 파일 스코프에서만 허용한다.

### 3.1.4 이름 해석과 오버로딩

이름 해석은 다음 3단계로 고정한다.

1. 오버로딩 규약으로 후보를 1차 축소한다.
2. 남은 후보가 있으면 우선순위를 적용한다.
3. 동일 우선순위에서 동일 시그니처 다중 후보가 남으면 `ambiguous`로 실패한다.

우선순위:

* 현재 파일
* 같은 폴더 auto-share(`export`만)
* 명시 `import` alias
* `deps` 외부 export

### 3.1.5 `nest`/`use`/가시성 경계

`nest`는 모듈 시스템이 아니라 네임스페이스 태깅 기능이다.

* `nest`는 선언의 심볼 경로를 부여한다.
* `import` head 계산과 module 해석에는 관여하지 않는다.
* `nest foo;` 파일 지시어는 파일당 1회만 허용한다.
* `use`는 로컬 alias/치환/acts 선택 용도로만 사용한다.

### 3.1.6 파일 item 규칙 (v0 고정)

Parus 파일 최상위는 `item` 집합으로 해석한다.

* 파일은 `item`과 `empty item`(`;`)의 반복을 허용한다.
* `declaration item`: `def`, `field`, `acts`, 전역 변수
* `directive item`: `import`, `use`, `nest path;`, `extern "C" ...;`
* `statement`는 블록 내부 전용이다.

가시성 규칙:

* 같은 파일: non-export 참조 허용
* 같은 폴더 다른 파일: export만 참조 허용
* 다른 폴더/다른 bundle: export + import + deps 검증 모두 충족 시 허용

### 3.2 `.` / `::` 접근 규칙

Parus v0는 경로 접근과 값 접근을 분리한다.

* `::`는 **경로(path) 접근 전용**이다.
  * `foo::math::add`
  * `Type::factory`
* `.`는 **값(value) 접근 전용**이다.
  * `obj.field`
  * `obj.method(...)`

금지 규칙:

* `obj::field` 금지
* `alias.obj` 금지
* 경로 접근에 `.` 사용 금지, 값 접근에 `::` 사용 금지

호출 lowering 규칙(v0):

* `obj.method(x)`는 메서드 해소 후 UFCS 형태로 lowering 가능하다.
* `Type::method(obj, x)`와 의미가 같더라도 표면 문법 규칙(`.` vs `::`)은 유지한다.

### 3.3 FFI 선언

* ABI/FFI 관련 정본은 `docs/reference/abi/v0.0.1/ABI.md`를 따른다.
* 본 절은 `ABI.md`의 요약이며, 충돌 시 본 절 해석을 중단하고 `ABI.md`를 적용한다.
* `use func::ffi`, `use struct::ffi` 문법은 폐기한다.
* FFI 경계 함수/전역은 `extern "C"` / `export "C"`로 선언한다.
* `pure`/`comptime`와 FFI의 결합 제약은 v0에서 상세 규칙을 보류한다.

예시

```parus
extern "C" def c_add(a: i32, b: i32) -> i32;
extern "C" static mut errno: i32;

export "C" def p_add(a: i32, b: i32) -> i32 {
  return a + b;
}
```

### 3.3.1 FFI-safe 타입 (`c-v0`)

허용:

* 정수: `i8/i16/i32/i64`, `u8/u16/u32/u64`, `isize/usize`
* 부동소수: `f32/f64`
* 포인터: `ptr T`, `ptr mut T` (T가 FFI-safe일 때)
* `layout(c)`를 만족하는 `field`

금지:

* borrow/escape (`&`, `&mut`, `&&`)
* optional, class, tablet 직접 값 전달
* 구현 의존 내부 타입

### 3.3.2 Parus의 개념이 C에서 어떻게 대응되는가

* `field` -> `struct` (C 호환 레이아웃)
* `handle<T>` -> `void*`(또는 `struct Handle_T*`) + 생성/해제 함수 세트
* `tablet` -> C에서 직접 값으로는 못 다루고, 반드시 `handle<tablet>`로만 다룬다
* `class`/`draft`/`pub-sub` -> **FFI로 직접 노출하지 않는다**
  대신:

  * “C가 호출할 수 있는 pub/sub wrapper 함수”를 제공하고,
  * 상태 접근은 wrapper 내부에서만 일어나게 한다.

예:

```parus
class Counter {
  def inc() : pub { draft.count += 1u32; commit; }
}

def counter_inc_ffi(h: handle<Counter>) -> void {
  // 내부적으로 h의 Counter 인스턴스에 대해 pub 호출
}
```

### 3.3.3 C 말고 다른 언어와의 FFI는 어떻게?

v0 권장 전략은 단순하다:

* **기본 ABI는 C ABI 하나로 통일**
* Rust/C++/Zig/Swift/Python 등은 각자의 방식으로 **C ABI를 소비**하게 한다.

언어별로는 대략 이렇게 된다:

* Rust: `extern "C"` + `#[repr(C)]` + `*mut c_void` 핸들
* C++: `extern "C"` + 포인터 핸들
* Zig: `extern` import + `[*]u8`/`?*anyopaque` 핸들
* Swift: C 헤더 브리징 + `OpaquePointer`/`UnsafeMutableRawPointer`
* Python: CPython extension 또는 ctypes/cffi로 C ABI 소비(핸들 기반)

이렇게 하면 “Parus 의미론”을 타 언어로 억지로 이식하지 않고, ABI는 깔끔하게 유지된다.
