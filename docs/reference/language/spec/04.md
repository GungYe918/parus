## 3. 프리패스와 단위 계층, `import`/`use`, FFI

### 3.1 단위 용어: file / module / bundle / project

Parus 빌드는 다음 4단위를 가진다.

* **file**: 하나의 소스 파일(`*.pr`). 파싱 단위이다.
* **module**: bundle 내부의 논리 코드 그룹(심볼 경로/가시성 단위).
* **bundle**: Rust crate 대응 컴파일/배포 단위. `parus.toml`을 가진다.
* **project**: 여러 bundle을 묶는 최상위 단위(workspace).

권장 계층:

```text
file -> module -> bundle -> project
```

핵심 규칙(전방선언 문제 제거):

* Parus은 **bundle 단위 선언 수집 prepass**를 수행한다.
* 따라서 같은 bundle 내부에서는 함수/타입/acts 선언 순서가 의미를 갖지 않는다.
* 같은 bundle 안에서는 파일 A가 파일 B의 뒤 선언 심볼을 전방선언 없이 참조할 수 있다.
* bundle 외부로 노출되는 심볼은 `export`로만 결정된다.

### 3.1.1 의존성 선언: manifest 우선

의존성은 소스 코드가 아니라 bundle manifest(`parus.toml`)에 선언한다.

```toml
[package]
name = "app"

[dependencies]
foo = { path = "../foo" }
goo = { path = "../goo" }
```

소스 코드의 `import`는 manifest에 선언된 의존성 키를 활성화하는 용도다.

### 3.1.2 `import` 문 (의존성/경로 alias 도입)

문법:

```parus
import foo;
import goo as g;
import foo::net as fnet;
```

규칙(v0 고정):

* `import`는 **include가 아니다**. 현재 스코프에 alias 심볼 1개를 도입한다.
* alias 생략 시 마지막 경로 세그먼트를 alias로 사용한다.
* 외부 심볼은 자동 평탄화되지 않는다. 항상 `alias::...`로 접근한다.
* `import`는 파일 스코프에서만 허용한다.
* `use module ...` 문법은 즉시 폐기한다.

심볼 접근 예시:

```parus
import foo;
import goo as g;

def demo() -> void {
  foo::math::add(a: 1, b: 2);
  g::io::print(msg: "ok");
}
```

### 3.1.3 `use` 문 (로컬 alias/치환 + acts 선택)

`use`는 로컬 축약/치환과 acts 선택에 사용한다.

1. 타입 별칭

```parus
use NewT = u32;
```

2. 경로 축약(alias)

```parus
use foo::math::add as add_i32;
use foo::io::print = println;
```

3. 스코프 상수/치환

```parus
use PI 3.14f;
use GAME_NAME "Parus";
```

4. 타입별 acts 세트 선택

```parus
use Vec2 with acts(A);
use Vec2 with acts(default);
```

5. 바인딩 시점 acts 선택(syntax sugar)

```parus
set mut v = Vec2{ x: 42, y: 42 } with acts(A);
let mut w: Vec2 = Vec2{ x: 1, y: 2 } with acts(default);
```

제약(v0 강제):

* `use`는 예약어/토큰을 바꾸지 않는다.
* `use NAME expr;` 치환 대상은 식별자(IDENT)만 가능하다.
* 함수형 매크로(인자), 토큰 결합/분해는 금지한다.
* acts 선택은 `use T with acts(NameOrDefault);` 문법만 허용한다.
* `use acts Foo for T;` 문법은 폐기한다.
* acts 선택 `use`는 파일/함수/블록 스코프에서 모두 허용하며, lexical scope 규칙을 따른다.
* 바인딩 sugar(`let/set ... = expr with acts(...)`)는 해당 바인딩의 dot/operator 해소 우선순위에만 영향한다.

### 3.1.4 `nest` 네임스페이스

`space` 키워드는 폐기하고 `nest`로 대체한다.

문법:

```parus
// 파일 기본 네임스페이스 지시어
nest engine::math;

// 블록형 선언
nest engine {
  nest math {
    export def add(a: i32, b: i32) -> i32 { return a + b; }
  }
}
```

규칙(v0):

* `nest` 내부 선언은 `a::b::c` 경로로 식별된다.
* `nest foo;` 파일 지시어는 파일당 1회만 허용한다.
* `nest` 내부에 `use`를 둘 수 있다(lexical alias).
* `import`는 파일 스코프에서만 허용한다.

### 3.1.5 파일 `item` 규칙 (v0 고정)

Parus는 파일 최상위를 `statement`가 아니라 `item` 집합으로 다룬다.

핵심 규칙:

* 파일은 `item`과 `empty item`(`;`)의 반복을 허용한다. (`statement`는 블록 내부 전용)
* `item = declaration item + directive item`
* `declaration item (braced)`:
  * `def` 본문 선언
  * `field`
  * `acts`
  * (미래) `proto` / `tablet` / `class`
  * 선언 자체는 종결 `;`를 요구하지 않는다
  * 뒤에 `;`가 오면 별도 `empty item`으로 해석한다 (허용)
* `simple item`:
  * `import` / `use`
  * `nest path;` (파일 지시어)
  * `extern "C" def ...;`
  * 전역 변수 선언
  * 끝 `;` 필수

용어/예제/진단 관례는 아래 문서를 함께 따른다.

* 용어 정본: `docs/reference/language/terminology.md`
* item 규칙 상세: `docs/reference/language/item-model.md`

### 3.2 `.` / `::` 접근 규칙

Parus v0는 경로 접근과 값 접근을 분리한다.

* `::`는 **경로(path) 접근 전용**이다.
  * `foo::math::add`
  * `Type::factory`
* `.`는 **값(value) 접근 전용**이다.
  * `obj.field`
  * `obj.method(...)`

금지 규칙:

* `obj::field` 금지
* `alias.obj` 금지
* 경로 접근에 `.` 사용 금지, 값 접근에 `::` 사용 금지

호출 lowering 규칙(v0):

* `obj.method(x)`는 메서드 해소 후 UFCS 형태로 lowering 가능하다.
* `Type::method(obj, x)`와 의미가 같더라도 표면 문법 규칙(`.` vs `::`)은 유지한다.

### 3.3 FFI 선언

* ABI/FFI 관련 정본은 `docs/reference/abi/v0.0.1/ABI.md`를 따른다.
* 본 절은 `ABI.md`의 요약이며, 충돌 시 본 절 해석을 중단하고 `ABI.md`를 적용한다.
* `use func::ffi`, `use struct::ffi` 문법은 폐기한다.
* FFI 경계 함수/전역은 `extern "C"` / `export "C"`로 선언한다.
* `pure`/`comptime`와 FFI의 결합 제약은 v0에서 상세 규칙을 보류한다.

예시

```parus
extern "C" def c_add(a: i32, b: i32) -> i32;
extern "C" static mut errno: i32;

export "C" def p_add(a: i32, b: i32) -> i32 {
  return a + b;
}
```

### 3.3.1 FFI-safe 타입 (`c-v0`)

허용:

* 정수: `i8/i16/i32/i64`, `u8/u16/u32/u64`, `isize/usize`
* 부동소수: `f32/f64`
* 포인터: `ptr T`, `ptr mut T` (T가 FFI-safe일 때)
* `layout(c)`를 만족하는 `field`

금지:

* borrow/escape (`&`, `&mut`, `&&`)
* optional, class, tablet 직접 값 전달
* 구현 의존 내부 타입

### 3.3.2 Parus의 개념이 C에서 어떻게 대응되는가

* `field` -> `struct` (C 호환 레이아웃)
* `handle<T>` -> `void*`(또는 `struct Handle_T*`) + 생성/해제 함수 세트
* `tablet` -> C에서 직접 값으로는 못 다루고, 반드시 `handle<tablet>`로만 다룬다
* `class`/`draft`/`pub-sub` -> **FFI로 직접 노출하지 않는다**
  대신:

  * “C가 호출할 수 있는 pub/sub wrapper 함수”를 제공하고,
  * 상태 접근은 wrapper 내부에서만 일어나게 한다.

예:

```parus
class Counter {
  def inc() : pub { draft.count += 1u32; commit; }
}

def counter_inc_ffi(h: handle<Counter>) -> void {
  // 내부적으로 h의 Counter 인스턴스에 대해 pub 호출
}
```

### 3.3.3 C 말고 다른 언어와의 FFI는 어떻게?

v0 권장 전략은 단순하다:

* **기본 ABI는 C ABI 하나로 통일**
* Rust/C++/Zig/Swift/Python 등은 각자의 방식으로 **C ABI를 소비**하게 한다.

언어별로는 대략 이렇게 된다:

* Rust: `extern "C"` + `#[repr(C)]` + `*mut c_void` 핸들
* C++: `extern "C"` + 포인터 핸들
* Zig: `extern` import + `[*]u8`/`?*anyopaque` 핸들
* Swift: C 헤더 브리징 + `OpaquePointer`/`UnsafeMutableRawPointer`
* Python: CPython extension 또는 ctypes/cffi로 C ABI 소비(핸들 기반)

이렇게 하면 “Parus 의미론”을 타 언어로 억지로 이식하지 않고, ABI는 깔끔하게 유지된다.

