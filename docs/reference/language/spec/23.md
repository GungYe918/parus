## 11. acts: 행동 묶음과 타입 부착(메서드/연산자)

보조 안내 문서는 `docs/architecture/acts/ACTS_MODEL.md`를 따른다. 충돌 시 본 섹션이 우선한다.

### 11.1 acts의 목적

* **field는 저장소, acts는 행동**이다. (field/class 내부에 “행동을 강제”하지 않고, 행동은 acts로 분리한다.)
* acts는 다음을 정의한다.

  1. **일반 함수(행동)**: 특정 기능의 표준 동작 집합을 제공
  2. **연산자(operator) 구현**: `+`, `==`, `++` 같은 토큰 연산의 의미를 타입별로 정의
* v0에서 acts는 “구조(타입)와 행동(함수/연산자)을 분리”하여

  * 파서/타입체커를 단순하게 유지하고
  * “어디에 메서드가 붙는지”를 명시적으로 드러내는 것을 목표로 한다.

---

### 11.2 acts의 세 형태: `acts A {}` vs `acts for T {}` vs `acts Name for T {}`

Parus v0에는 acts 블록이 세 가지 형태로 존재한다.

#### (1) 일반 acts(네임스페이스): `acts A { ... }`

* `acts A {}`는 A라는 이름의 acts 네임스페이스(행동 묶음)를 만든다.
* 이 블록 안의 선언은 정적 경로 호출(`acts(A)::f(...)`)로만 사용한다.
* alias를 쓸 때는 `use acts(A) as a; a::f(...);`를 사용한다.
* `acts A` 내부 함수는 dot 호출 sugar 대상이 아니다.
* `acts A` 내부 함수는 `self` 리시버를 가질 수 없다.
* `acts A` 내부에 operator 선언은 금지한다.

예시:

```parus
acts Math {
  def add(a: i32, b: i32) -> i32 { return a + b; }
}

def demo() -> void {
  set x = acts(Math)::add(1, 2);
}
```

---

#### (2) 기본 부착형 acts: `acts for T { ... }`

* `acts for T`는 타입 `T`의 **default acts**다.
* default acts는 타입에 자동 부착되며, named acts lookup 실패 시 fallback 대상으로 사용된다.
* 부착 대상 제한(v0):
  * 허용: `field`, `class`
  * 금지: `actor`, `proto`

핵심 규칙(v0):

* 타입 `T`의 default acts 집합은 의미적으로 하나여야 한다.
* 동일 시그니처(함수 시그니처 / operator key + 시그니처) 중복 정의는 에러다.

예시:

```parus
acts for Packet {
  def checksum(self, seed: u32) -> u32 { return self.crc + seed; }
}

def demo(p: Packet) -> void {
  set a = p.checksum(5u32);
  set b = Packet::acts(default)::checksum(&p, 5u32);
}
```

---

#### (3) 이름 있는 부착형 acts: `acts Name for T { ... }`

* `acts Name for T`는 타입 `T`에 부착되는 named acts 세트다.
* named acts는 자동 활성되지 않는다.
* 활성화는 `use T with acts(Name);`로 수행한다.
* 부착 대상 제한은 default acts와 동일하다(`field`/`class`만 허용).

예시:

```parus
acts FastMath for Vec2 {
  operator(+)(self, rhs: Vec2) -> Vec2 { ... }
}
```

---

### 11.3 acts 선택 문법과 스코프 규칙

acts 세트 선택 문법은 아래로 고정한다.

```parus
use Vec2 with acts(FastMath);
use Vec2 with acts(default);
```

```parus
set mut v = Vec2{ x: 42, y: 42 } with acts(FastMath);
```

규칙(v0):

1. `use T with acts(Name);`는 현재 lexical scope에서 타입 `T`의 활성 named acts를 `Name`으로 설정한다.
2. `use T with acts(default);`는 현재 lexical scope에서 타입 `T`를 default acts 전용으로 되돌린다.
3. acts 선택 `use`는 파일/함수/블록 스코프에서 모두 허용한다.
4. 내부 스코프 선택이 외부 스코프 선택을 shadowing하며, 블록 종료 시 자동 해제된다.
5. 폐기 문법: `use acts Foo for T;`
6. 바인딩 sugar(`let/set ... = expr with acts(...)`)는 해당 바인딩의 dot/operator 해소 우선순위에 적용된다.

명시 경로 선택(v0):

```parus
Vec2::acts(FastMath)::add(v, 1, 2);
Vec2::acts(default)::add(v, 1, 2);
```

alias 정합성 규칙(v0):

1. `use Vec2 as v2;`를 선언했다면 `v2::acts(FastMath)::add(...)`도 동일하게 유효해야 한다.
2. `use acts(Math) as m;`를 선언했다면 `m::add(...)`로 일반 acts 네임스페이스 함수에 접근할 수 있어야 한다.
3. alias 해석은 import/path/type/acts alias를 통합한 lexical alias resolver로 동작해야 한다.

---

### 11.4 export 규칙: acts 블록 단위 export만 허용

v0에서 export는 acts 블록 전체에만 적용한다.

```parus
export acts for Packet {
  def checksum(self, seed: i32) -> u32 { ... }
}
```

금지:

```parus
acts for Packet {
  export def checksum(...) -> u32 { ... } // 금지
}
```

---

### 11.5 `acts for T` / `acts Name for T` 리시버(self) 규칙

`self`는 파라미터 이름이 아니라 리시버 마커다.

```parus
def checksum(self, seed: u32) -> u32 { ... }
```

강제 규칙(v0):

1. `self`는 첫 번째 파라미터 위치에서만 허용한다.
2. `acts for T` / `acts Name for T` 내부 함수는 첫 파라미터로 `self` 계열이 필수다.
3. `self` 표기는 `self` / `self mut` 두 형태만 허용한다.
4. `self move`는 v0에서 보류한다.
5. 의미:
   - `self`      : `&Self`
   - `self mut`  : `&mut Self`
6. 일반 `acts A {}` 내부 함수에는 `self`를 쓸 수 없다.
7. `self`가 붙은 함수만 메서드(dot 호출) 대상이다.

dot 호출 lowering:

```parus
x.f(1, 2);      // == T::acts(default)::f(&x, 1, 2)
T::acts(default)::f(&x, 1, 2);
```

주의(v0):

1. `Class::m(...)`, `Proto::m(...)` 형태의 경로 호출은 제거된다.
2. acts 명시 경로 `T::acts(Name)::m(...)`는 유지된다.

---

### 11.6 연산자 오버로딩 규칙

연산자 선언은 `operator(...)` 문법만 사용한다.

```parus
operator(+)(self, rhs: T) -> T { ... }
operator(==)(self, rhs: &T) -> bool { ... }
operator(++pre)(self mut) -> T { ... }
operator(++post)(self mut) -> T { ... }
```

규칙(v0):

1. `operator(...)`는 `def` 키워드를 쓰지 않는다.
2. operator 선언은 `acts for T`와 `acts Name for T`에서만 허용한다.
3. 일반 `acts A {}` 안의 operator 선언은 금지한다.
4. operator 해석은 활성 named acts 우선, 없으면 default acts fallback 순서를 따른다.

---

### 11.7 메서드/연산자 해석 규칙 (named-first + default fallback)

타입이 `T`이고 현재 스코프 선택이 `use T with acts(S);`일 때:

1. `acts S for T`에서 후보를 먼저 찾는다.
2. 없으면 `acts for T`(default)에서 찾는다.
3. 그래도 없으면 builtin 규칙(해당 시)으로 넘어가고, 없으면 타입 에러다.

`use T with acts(default);`일 때:

1. default acts만 사용한다.
2. named acts는 조회하지 않는다.

충돌 규칙(v0, 필수):

1. 활성 named acts와 default acts에 동일 시그니처가 동시에 존재하면 컴파일 에러다.
2. 같은 lexical scope에서 타입 `T`에 서로 다른 named acts를 동시에 활성화하면 컴파일 에러다.

---

### 11.8 예시 모음

#### (1) default acts만 사용

```parus
export field Foo {
  v: u32;
}

export acts for Foo {
  def inc(self mut) -> void { self.v = self.v + 1u32; }
  operator(+)(self, rhs: Foo) -> Foo { return Foo{ v: self.v + rhs.v }; }
}

def demo(mut a: Foo, b: Foo) -> Foo {
  a.inc();
  return a + b;
}
```

#### (2) named acts 선택 + fallback

```parus
export acts FooMath for Foo {
  operator(+)(self, rhs: Foo) -> Foo {
    return Foo{ v: __intrin_u32_saturating_add(self.v, rhs.v) };
  }
}

def demo2(a: Foo, b: Foo) -> Foo {
  set x = a + b;                 // default acts

  use Foo with acts(FooMath);    // 현재 스코프에서 named 선택
  set y = a + b;                 // FooMath 우선

  use Foo with acts(default);    // default로 복귀
  set z = a + b;
  return z;
}
```

#### (3) 블록 단위 acts 선택

```parus
def demo3(a: Foo, b: Foo) -> Foo {
  set x = a + b;                 // 외부 스코프: default
  {
    use Foo with acts(FooMath);  // 내부 블록에서만 FooMath
    set y = a + b;
  }
  return x + b;                  // 블록 종료 후 default
}
```
