## 9. actor, draft, pub/sub, commit, recast

### 9.0 draft의 실체: “스냅샷 + 스테이징(draft) 버퍼” 모델(명문화)

actor는 “큰 공유 상태”를 제공한다. v0의 핵심 구현 모델은 다음이다.

* **Published Snapshot**: sub가 읽는 불변 스냅샷
* **draft Buffer**: pub가 수정하는 스테이징 버퍼(아직 발행되지 않음)

즉, pub에서 `draft.x = ...`는 “즉시 공유 메모리를 찌르기”가 아니라,
**스테이징 버퍼에 변경을 기록**하는 동작이다. `commit;`에서만 발행된다.

이 모델은 OS 의존이 아니다.

* 멀티스레드 동기화는 표준 라이브러리(또는 런타임)가 제공하는 최소 프리미티브(원자적 포인터 스왑, 스핀락/뮤텍스)만으로 구현 가능
* freestanding에서도 동일

### 9.1 actor 정의

* actor는 대단위 공유 컨텍스트 단위다.
* draft는 actor가 보유하는 상태의 논리적 이름이다.
* draft 접근은 sub/pub 모드 함수에서만 허용한다.

예시

```parus
actor Game {
  // draft.score 같은 상태가 존재한다고 가정

  def sub score() -> int { return draft.score; }
}
```

### 9.2 sub 규칙

* draft 읽기만 가능
* draft에 대한 대입, 가변 변경 금지
* recast; 는 sub 내부에서 "현재 sub가 보는 draft 스냅샷을 재구성(recast)하여 최신 상태로 다시 캐스팅/재해석"하는 제어 구문으로 사용된다.

recast (추가 설명):

* sub가 보는 draft는 “함수 진입 시점의 스냅샷”이다(렉시컬 일관성).
* `recast;`는 **현재 스레드/호출이 들고 있는 스냅샷 핸들을 최신으로 다시 잡는** 제어 구문이다.


또한 pub/sub에서 commit, recast는 단순 함수 호출이 아니라 "제어 구문"으로 취급한다 (추가):

* continue가 루프 흐름을 바꾸는 것처럼, commit/recast는 "상태 흐름을 바꾸는 제어 구문"이다.
* 예를 들어, pub에서 commit은 "draft 변경분을 발행"하고 pub의 상태 단계를 종료시키는 의미를 갖는다.
* sub에서 recast는 "draft 관찰 뷰"를 재설정하는 의미를 갖는다.
* 따라서 if 내부에서 continue를 쓰듯이, if 내부에서 recast/commit을 쓸 수 있으며, 이는 "제어적 의미"를 가진다.

  * 단, pub의 최종 commit 강제 규칙은 그대로 적용된다. (if 내부 commit은 최종 commit으로 인정되지 않는다)

예시:

```parus
actor Counter {
  def sub get() -> u32 {
    // 오래된 스냅샷이면 갱신하고 싶을 때
    if (draft.stale) {
      recast;
    }
    return draft.count;
  }
}
```

### 9.3 pub 규칙

핵심 규칙:

* pub 함수는 draft 수정 가능
* 최종 commit은 "함수 본문 최상위 블록의 마지막 유효 문장" 이어야 한다.
* 분기/중첩 블록 내부의 commit은 최종 commit 검사에서 무시한다.
* pub는 draft를 수정할 수 있다. 단, v0의 흐름 규칙은 더 엄격히 고정한다.
* pub는 내부적으로 “발행 가능한 변경 집합”을 만든다.
* `commit;`을 실행하면 현재 변경 집합이 발행되고, pub는 계속 진행 가능(아래 9.X.5)


v0 권장:

* pub는 void return
* pub 내부 return 금지

추가 (제어 구문 성격 강조):

* pub에서 commit은 단순 문장 종료가 아니라 "발행 단계"를 수행하는 제어 구문이다.
* if 안에서 commit을 쓰는 것은 "조기 발행"처럼 보일 수 있으나, v0의 최종 commit 규칙에서는 최종으로 인정되지 않는다.
* 따라서 v0에서는 if 내부 commit은 허용하되 경고를 권장하거나, 아예 금지로 시작해도 된다. (정책 선택)
* mut 가능하되, commit 전후로 borrow가 살아있으면 에러

예시

```parus
actor Counter {
  def pub add(delta: int) -> void {
    if (delta < 0) {
      // commit; // 있어도 최종 commit으로는 인정되지 않음 (정책에 따라 경고/에러 가능)
    }
    draft.count += delta;
    commit;
  }
}
```

### 9.3.1 pub에서 `&&`는 “핸들 생성(승격)”이며 draft로는 “대입”만 한다

pub의 핵심은 “draft 변경 + 최종 commit”이다. `&&`는 “소유권 탈출”이므로 pub에서 흔히 쓰일 수 있다:

예:

```parus
def add_sprite() : pub {
  set s = Sprite();
  draft.sprite = &&s;   // handle로 승격해 draft에 저장
  commit;
}
```

### 9.3.2 pub/sub에서 draft에 대한 “move-out” 금지

draft는 “공유 상태의 저장소”이므로, v0에서는 draft에서 값을 꺼내 move 하는 것을 금지하는 게 안전하다.

**v0 규칙:**

* `&&draft.x` 금지
* `set y = draft.x;` 는 Copy 가능한 타입이면 허용(복사/읽기)
* handle은 “값 복사(핸들 복제)”가 아니라 **핸들 규약**에 따른다(예: handle은 move-only, arc는 clone 등)

이 규칙을 넣으면 draft의 일관성/원자성 모델이 깨지는 걸 막을 수 있어.

### 9.3.3 commit의 경계 정의(강제): “publish barrier” + “borrow/alias 리셋 지점”

`commit;`은 단순한 문장이 아니라, **상태 경계**다.

commit 경계에서의 규칙(강제):

1. **commit을 넘는 borrow 금지**

   * pub에서 `&mut` 포함 모든 borrow 값(`&T`, `&mut T`, `&[T]`, `&mut [T]`)이 살아있는 상태로 `commit;` 실행 경로에 도달하면 에러
2. **draft에 대한 alias 규칙(배타)**

   * 같은 pub의 동일 스테이징 구간에서, 동일 draft 셀(예: `draft.x`, `draft.arr[i]`)에 대해

     * `&mut` alias가 2개 이상 생기면 에러
     * `&mut`이 존재하는 동안 동일 셀에 대한 읽기/쓰기 직접 접근도 에러(v0 보수 규칙)
3. **draft move-out 금지 유지**

   * `&&draft.x` 금지
   * draft에서 꺼내는 건 “읽기(copy/clone/handle 규약)”만 허용

예시(금지):

```parus
actor Bad {
  def pub f() -> void {
    set r = &mut draft.count;
    draft.count = 1u32;
    commit;              // error: borrow 살아있음
  }
}
```


### 9.3.4 commit 시점 제약: “commit을 넘는 borrow 금지”를 명문화

이미 본문에 힌트가 있으니, 딱 한 줄 규칙으로 고정:

* pub 블록에서 `commit;`이 실행되는 경로에서, `&mut` borrow(또는 어떤 borrow든)가 살아있으면 에러.

### 9.3.5 pub에서 “commit 여러 번 허용”(요청 반영, v0 확정)

pub는 한 번의 호출 안에서 여러 번 commit할 수 있다. 의미는 다음으로 고정한다.

* `commit;`을 실행하면 **현재까지의 draft 변경이 발행**된다.
* 그 즉시 pub는 **새 스테이징 단계**로 진입한다.

  * 이후의 `draft.*` 접근/수정은 “방금 발행된 최신 스냅샷”을 베이스로 하는 새로운 draft로 간주한다.
* 즉, pub 내부는 다음처럼 여러 “발행 단계”를 가질 수 있다:

```parus
actor Progress {
  def pub run() -> void {
    draft.step = 1u32;
    commit;          // step=1 발행

    draft.step = 2u32;
    commit;          // step=2 발행

    draft.step = 3u32;
    commit;          // step=3 발행 (최종)
  }
}
```

이 규칙은 멀티스레드에서도 안전한 모델을 유지한다.

* sub는 각자 잡은 스냅샷을 읽으며, 필요할 때만 `recast;`로 최신을 본다.
* pub의 각 commit은 “원자적 스냅샷 교체(또는 버전 증가)”로 구현된다.

---

### 9.3.6 pub 함수의 return 정책(요청 반영, v0 확정)

pub는 “상태 발행을 반드시 명시”해야 하므로, 반환 정책을 다음으로 고정한다.

* pub는 **일반 `return`을 금지**한다. (조기 탈출이 commit 규칙을 깨기 쉬움)
* pub에서 값을 반환하려면 아래 단 하나만 허용한다:

#### (1) `commit return Expr;` (신규 문법, pub 전용)

* 의미: “현재 draft를 발행하고, Expr 값을 반환하며, pub를 종료”
* `commit return ...;` 는 **함수 최상위 블록에서만**, 그리고 **마지막 문장으로만** 허용한다.

예시:

```parus
actor Counter {
  def pub add(delta: u32) -> u32 {
    draft.count += delta;
    commit return draft.count;     // 발행 + 반환
  }
}
```

#### (2) void pub는 `commit;`으로 종료

```parus
actor Counter {
  def pub inc() -> void {
    draft.count += 1u32;
    commit;                        // 발행 + 종료(암묵 return)
  }
}
```

> 결과적으로 “pub의 종료는 항상 commit과 결합”된다.
> 컴파일러 입장에선 CFG가 매우 단순해지고, 규칙 위반 진단도 쉬워진다.

---

### 9.3.7 “draft에 뭔가를 넣는(insert/append) 동작”의 위치: 표준 컨테이너는 **handle로 draft에 저장**(권장)

draft는 “데이터 레코드 + 핸들”로 유지한다(기존 철학 강화).

* draft 내부에 동적 컨테이너를 값으로 두지 않는다.
* draft에는 `handle<Vec<T>>` 같은 핸들만 두고,
* 실제 push/append는 핸들이 가리키는 구현체(class/컨테이너)에 대해 수행한다.

예시(권장 패턴):

```parus
actor Scene {
  // draft.sprites: handle<SpriteList> 라고 가정

  def pub add_sprite(s: handle<Sprite>) -> void {
    // SpriteList는 class이고, draft에는 handle만 저장
    draft.sprites.push(x: s);   // push는 handle/class 쪽 메서드
    commit;
  }

  def sub count() -> u32 {
    return draft.sprites.len();
  }
}
```

이 패턴은 OS 의존이 없다.

* freestanding에서는 컨테이너가 내부적으로 “사용자 제공 allocator” 또는 “고정 풀”을 쓰면 된다.
* draft는 여전히 “스냅샷/발행 모델”만 담당한다.

---

### 9.3.8 멀티스레드 안전성 요약(문서에 포함, 구현 가이드)

v0에서 actor는 다음 성질을 목표로 한다.

* sub: 락 없이 읽을 수 있다(스냅샷 포인터/버전 기반)
* pub: 단일 writer(혹은 내부 락)로 직렬화된다
* commit: 원자적 스냅샷 교체(atomic swap) + 필요 시 epoch 기반 reclamation(표준 라이브러리 구현 영역)

즉, 사용자는 OS 없이도 일관된 규칙을 얻는다.

* “sub는 읽기 전용 스냅샷”
* “pub는 draft 수정”
* “commit은 publish barrier”

---

### 9.4.1 “선언(Decl) 포함”과 “값(Instance) 포함”을 구분한다

* `field/proto/class/acts/actor`는 서로 **중첩 선언**(nested declaration)을 허용할 수 있다.
  (이건 네임스페이스/스코프 설탕이라 구현 난이도 낮음)
* 하지만 “값으로 포함(멤버로 저장)”은 별도 규칙을 따른다.

> v0 권장: 중첩 선언은 허용하되, ABI/가시성 규칙은 “그냥 내부 스코프의 top-level”로 취급한다.

### 9.4.2 actor(draft 상태)에 포함 가능한 것

actor의 draft는 “대단위 공유 상태”이므로, v0에서는 **복잡한 생명주기/소유권이 끼는 값**을 draft에 직접 넣지 않는 게 안정적이다.

**v0 규칙:**

* draft에 직접 포함 가능:

  * 원시 타입, `char`, `bool`
  * `field` (단, field가 FFI-safe/POD 조건을 만족할 때)
  * 고정 배열 `T[N]` (T가 POD일 때)
  * `handle<T>` 같은 **핸들 계열**(표준 라이브러리 타입, 불투명 소유)
* draft에 직접 포함 금지:

  * `class` “값 인스턴스”
  * `actor` 인스턴스
  * `string`, `T[]` 등 동적 소유/할당이 필요한 것(정책상 v0 금지 권장)
  * `&T`, `&mut T` (borrow)

**의도:** draft는 “데이터 레코드 + 핸들”로 유지하고, 리소스 생명주기/소유권은 handle로만 표현한다.

### 9.4.3 class 내부에 포함 가능한 것

class은 “일반 구현 타입”이므로 멤버 포함을 폭넓게 허용할 수 있다. 다만 actor는 예외로 두는 걸 추천한다.

**v0 규칙(권장):**

* class에 포함 가능:

  * field, 원시 타입, 고정 배열, handle<T>, string(허용 여부 정책)
  * 다른 class 인스턴스(가능) *하지만 생성자/소멸자 호출이 존재*
* class에 포함 금지:

  * actor 인스턴스 (draft/publish 모델과 충돌: “객체 내부에 또 공유상태 머신”이 들어오면 모델이 무너짐)
  * borrow 타입 멤버(`&T`, `&mut T`) (비탈출 원칙과 충돌)

> **중요 포인트:** class를 actor draft에 “값으로” 넣는 건 금지하되, class는 어디서든 **handle<class>**로는 담을 수 있다.
> 즉 “큰 상태 = handle로 들고, draft에는 handle만 저장”이 기본 패턴.

---
