## 3.4 `-ffreestanding` / `-fno-std` 경계 정의

참고:

1. bundle/module/import/export 가시성 규칙 정본은 `docs/reference/language/spec/30_BUNDLE_MODULE_RESOLUTION.md`를 따른다.
2. `import foo::bar` / `import ::foo::bar` 절대 표기 규칙도 위 정본 문서를 따른다.
3. 본 문서는 런타임/표준 라이브러리 경계 규칙만 다룬다.

### 3.4.1 두 모드의 목적

* `-ffreestanding` : OS/호스트 환경을 가정하지 않는다.

  * 표준 라이브러리는 “freestanding 프로파일”로 링크 가능(선택)
  * 원자/스핀락/기본 핸들/Result 정도는 제공 가능
* `-fno-std` : 표준 라이브러리 **전체 미사용**.

  * `core`(컴파일러 내장 최소 모듈)만 사용 가능
  * 런타임 의존 기능은 전부 금지

---

### 3.4.2 예외 기능과의 경계(v0 강제)

예외 메커니즘(`?`, `throw`, `try...catch`, `attempt`)은 런타임 지원이 필요할 수 있으므로 v0에서는 다음처럼 고정한다.

* `-fno-std` 에서는:

  * `? 함수` 선언 자체를 **금지**(또는 선언은 허용하되 본문에서 throw/try/attempt 전부 금지로 시작해도 되지만, v0는 “금지”가 더 단단함)
  * `throw`, `try...catch`, `attempt` 전부 **컴파일 에러**
  * 에러 핸들링은 **Result<T> + switch**만 사용
* `-ffreestanding` 에서는:

  * 표준 라이브러리 freestanding 프로파일이 “EH 지원”을 포함하는 경우에만 `? / throw / attempt` 허용
  * 그렇지 않으면 `-fno-std`와 동일하게 금지

이 경계 덕분에:

* 커널/펌웨어/부트로더 같은 환경은 Result 기반으로 매우 예측 가능한 코드 생성이 가능
* 사용자 앱/툴링 환경은 ? 함수로 더 편한 전파 모델을 쓸 수 있다

---
