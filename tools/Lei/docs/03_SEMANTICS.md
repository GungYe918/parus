# 03. Semantics

## 평가 모델

1. 모듈은 선언과 실행 컨텍스트를 가진다.
2. import는 DAG 순서로 해석된다.
3. 같은 입력/옵션이면 동일한 출력을 생성해야 한다.
4. LEI 언어는 `master` 개념을 갖지 않는다.

## 값 모델

1. 스칼라: `int`, `float`, `string`, `bool`
2. 컨테이너: object, array
3. 함수 값: `def`로 선언된 블록 함수
4. plan 값: `plan` 선언으로 생성된 명명된 플랜 값

## 가변성

1. `let`은 재대입 불가다.
2. `var`는 재대입 가능하다.
3. `=`은 명시 대입이다.

## 접근 의미

1. `obj.field`는 객체 필드 접근이다.
2. `arr[idx]`는 배열 인덱스 접근이다.
3. `alias::symbol`은 import namespace 접근이다.

## `&` (엄격 합성) 규칙

1. `A & B`는 새 값을 만든다. 원본은 변경되지 않는다.
2. object-object는 재귀 합성한다.
3. 같은 키의 scalar는 타입과 값이 동일할 때만 통과한다.
4. array-array는 길이가 같아야 하며, 각 인덱스를 재귀 합성한다.
5. 타입 불일치 또는 값 충돌은 실패다.
6. 충돌 진단은 경로를 포함해야 한다.
   예: `build.profile`, `bundles[2].deps[0]`
7. `&`는 덮어쓰기가 아니다.

## 빌트인 plan과 스키마

1. LEI 언어 자체는 `bundle`, `master`, `project`의 의미를 내장하지 않는다.
2. 호스트(예: Parus)는 빌트인 plan 값을 주입할 수 있다.
3. 주입된 빌트인 plan과 사용자 patch를 `&`로 합성해 schema 제약을 적용할 수 있다.
4. 어떤 plan이 특수한지는 언어가 아니라 통합 프로파일이 결정한다.

## 함수 의미

1. 함수는 블록 본문을 가진다.
2. `return`으로 값을 반환한다.
3. 재귀 호출은 금지한다.
4. 중첩 함수는 금지한다.

## 제어 의미

1. `if`는 조건 블록 분기다.
2. `for`는 예산 제한 하에서만 실행된다.
3. 예산 초과는 즉시 실패한다.

## 오류 규칙

1. 미정의 식별자, 타입 충돌, 합성 충돌은 즉시 실패한다.
2. 실패는 silent fallback 없이 결정적 진단으로 보고한다.
