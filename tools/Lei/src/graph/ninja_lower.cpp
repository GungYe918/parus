#include <lei/graph/BuildGraph.hpp>

#include <algorithm>
#include <set>
#include <sstream>

namespace lei::graph {

namespace {

const lei::eval::Value* find_key(const lei::eval::Value::Object& obj, const std::string& key) {
    auto it = obj.find(key);
    if (it == obj.end()) return nullptr;
    return &it->second;
}

} // namespace

BuildConventions make_default_build_conventions() {
    return BuildConventions{};
}

std::optional<BuildGraph> from_build_value(const lei::eval::Value& v,
                                           lei::diag::Bag& diags,
                                           const BuildConventions& conventions) {
    BuildGraph g{};

    auto root = v.as_object();
    if (!root) {
        diags.add(lei::diag::Code::B_INVALID_BUILD_SHAPE, "<entry>", 1, 1,
                  "export build value must be object");
        return std::nullopt;
    }

    const auto* bundles_v = find_key(*root, conventions.bundles_field);
    if (!bundles_v || !bundles_v->is_array()) {
        diags.add(lei::diag::Code::B_INVALID_BUILD_SHAPE, "<entry>", 1, 1,
                  "build object must contain array field '" + conventions.bundles_field + "'");
        return std::nullopt;
    }

    const auto& bundles = std::get<lei::eval::Value::Array>(bundles_v->data);
    for (const auto& b : bundles) {
        auto bobj = b.as_object();
        if (!bobj) {
            diags.add(lei::diag::Code::B_INVALID_BUILD_SHAPE, "<entry>", 1, 1,
                      "bundle entry must be object");
            return std::nullopt;
        }

        const auto* name_v = find_key(*bobj, conventions.bundle_name_field);
        if (!name_v || !name_v->is_string()) {
            diags.add(lei::diag::Code::B_INVALID_BUILD_SHAPE, "<entry>", 1, 1,
                      "bundle must contain string field '" + conventions.bundle_name_field + "'");
            return std::nullopt;
        }
        g.bundle_names.push_back(std::get<std::string>(name_v->data));

        const auto* module_map_v = find_key(*bobj, conventions.module_map_field);
        if (module_map_v && module_map_v->is_object()) {
            const auto& mmap = std::get<lei::eval::Value::Object>(module_map_v->data);
            for (const auto& [mod_name, files_v] : mmap) {
                (void)mod_name;
                auto arr = std::get_if<lei::eval::Value::Array>(&files_v.data);
                if (!arr) continue;
                for (const auto& f : *arr) {
                    auto sp = std::get_if<std::string>(&f.data);
                    if (sp) g.module_files.push_back(*sp);
                }
            }
        }
    }

    std::sort(g.bundle_names.begin(), g.bundle_names.end());
    std::sort(g.module_files.begin(), g.module_files.end());
    return g;
}

std::optional<std::string> emit_ninja(const BuildGraph& graph, lei::diag::Bag& diags) {
    (void)diags;
    std::ostringstream oss;
    oss << "# generated by lei-build\n";
    oss << "ninja_required_version = 1.10\n\n";

    oss << "rule touch\n";
    oss << "  command = /usr/bin/env true\n\n";

    std::set<std::string> outputs;
    for (const auto& b : graph.bundle_names) {
        const std::string out = "out/" + b + ".stamp";
        outputs.insert(out);
        oss << "build " << out << ": touch";
        for (const auto& f : graph.module_files) {
            oss << " " << f;
        }
        oss << "\n";
    }

    oss << "\nbuild all: phony";
    for (const auto& out : outputs) {
        oss << " " << out;
    }
    oss << "\ndefault all\n";

    return oss.str();
}

} // namespace lei::graph
